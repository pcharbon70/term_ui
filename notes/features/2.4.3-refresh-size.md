# Feature: Task 2.4.3 - Implement refresh_size/1 Callback

**Branch:** `feature/2.4.3-refresh-size`
**Base:** `multi-renderer`
**Date:** 2025-12-05

## Overview

Implement the `refresh_size/1` callback for the Raw backend to re-query terminal dimensions. This is typically called after receiving a SIGWINCH signal to update the cached size.

## Reference

See `notes/planning/multi-renderer/phase-02-raw-backend.md` Section 2.4.3.

## Tasks

### Implementation

- [ ] 2.4.3.1 Implement `refresh_size/1` querying `:io.columns/0` and `:io.rows/0`
- [ ] 2.4.3.2 Update `size` field in state
- [ ] 2.4.3.3 Return `{:ok, new_size, updated_state}`
- [ ] 2.4.3.4 Document that this should be called after SIGWINCH handling

### Unit Tests

- [ ] Test `refresh_size/1` returns `{:ok, new_size, updated_state}` tuple
- [ ] Test `refresh_size/1` updates state with new dimensions
- [ ] Test `refresh_size/1` handles `:io.columns/0` or `:io.rows/0` failure gracefully
- [ ] Test `refresh_size/1` preserves other state fields

## Implementation Details

### Return Value Pattern

Unlike `size/1` which returns `{:ok, size}`, `refresh_size/1` returns a 3-tuple:
```elixir
{:ok, new_size, updated_state}
```

This pattern:
1. Provides the new size directly for immediate use
2. Returns updated state for caller to track
3. Distinguishes success from error cases

### Error Handling

When `:io.rows/0` or `:io.columns/0` fails:
- Return `{:error, :size_detection_failed}`
- Original state is unchanged
- Caller can decide how to handle (use previous size, default, etc.)

### SIGWINCH Integration

The `refresh_size/1` function should be called from the SIGWINCH signal handler:
```elixir
# In runtime/signal handler
def handle_info({:signal, :sigwinch}, state) do
  case Raw.refresh_size(state.backend_state) do
    {:ok, new_size, new_backend_state} ->
      # Update state and trigger re-render
      ...
    {:error, _reason} ->
      # Keep existing size
      ...
  end
end
```

### Reusing Existing Logic

The `get_terminal_size/1` private function already handles:
- Querying `:io.rows/0` and `:io.columns/0`
- Falling back to LINES/COLUMNS environment variables
- Returning `{:error, :size_detection_failed}` on failure

We can reuse this for `refresh_size/1`:
```elixir
def refresh_size(state) do
  case get_terminal_size(nil) do
    {:ok, new_size} ->
      {:ok, new_size, %{state | size: new_size}}
    {:error, reason} ->
      {:error, reason}
  end
end
```

## Files to Modify

- `lib/term_ui/backend/raw.ex` - Add refresh_size/1 function
- `test/term_ui/backend/raw_test.exs` - Add refresh_size/1 tests
- `notes/planning/multi-renderer/phase-02-raw-backend.md` - Mark tasks complete

## Verification

1. `mix compile` - no warnings
2. `mix test test/term_ui/backend/raw_test.exs` - all tests pass
3. `mix format --check-formatted` - code formatted
