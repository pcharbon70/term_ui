# Feature Plan: 3.1 Component Behaviours

## Problem Statement

The component system needs standardized interfaces that all widgets implement. Without well-defined behaviours:
- Widget implementations become inconsistent and unpredictable
- The runtime cannot treat widgets uniformly regardless of type
- Code reuse is difficult as there's no shared foundation
- Testing becomes harder without clear contracts to verify

We need to define three core behaviours:
1. **Component** - Base behaviour for stateless display widgets (labels, dividers)
2. **StatefulComponent** - Extension for widgets maintaining internal state (buttons, inputs)
3. **Container** - Extension for widgets that manage child components (panels, forms)

These behaviours establish the foundation for The Elm Architecture pattern adapted for OTP, where components receive events as messages, maintain state via GenServer callbacks, produce render trees, and emit commands for side effects.

## Solution Overview

Implement four core modules that define the component interface:

1. `TermUI.Component` - Base behaviour with render callback
2. `TermUI.StatefulComponent` - State management extension
3. `TermUI.Container` - Child management extension
4. `TermUI.Component.Helpers` - Common utilities for all components

### Key Design Decisions

- **`@callback` definitions with typespecs** - Clear contracts with compile-time verification
- **`@optional_callbacks`** - Minimal required surface with rich optional hooks
- **`__using__` macros** - Inject default implementations and imports
- **Composable behaviours** - StatefulComponent uses Component, Container uses StatefulComponent
- **Render tree types** - Flexible output format (nodes, lists, strings)

### Behaviour Hierarchy

```
Component
    |
StatefulComponent (uses Component)
    |
Container (uses StatefulComponent)
```

## Technical Details

### File Structure

```
lib/term_ui/
├── component.ex              # Base Component behaviour
├── stateful_component.ex     # StatefulComponent behaviour
├── container.ex              # Container behaviour
└── component/
    ├── helpers.ex            # Shared helper functions/macros
    └── render_node.ex        # RenderNode struct

test/term_ui/
├── component_test.exs
├── stateful_component_test.exs
├── container_test.exs
└── component/
    └── helpers_test.exs
```

### Core Types

```elixir
# Render tree output types
@type render_tree :: RenderNode.t() | [render_tree()] | String.t()

# Event types (from Phase 1)
@type event :: KeyEvent.t() | MouseEvent.t() | FocusEvent.t()

# Command type for side effects
@type command :: {:send, pid(), term()} | {:timer, integer(), term()} | term()

# Area/bounds type
@type rect :: %{x: integer(), y: integer(), width: integer(), height: integer()}

# Child specification for containers
@type child_spec :: {module(), props :: map()} | {module(), props :: map(), id :: term()}

# Component reference for routing
@type component_ref :: {pid(), id :: term()}
```

### Dependencies

- Phase 2 complete (rendering engine) - for Style module
- No external dependencies

### Patterns from Existing Code

Following patterns established in the renderer modules:

1. **Struct definition with typespecs** (from Cell/Style)
2. **Validation helpers** (from Cell/Style)
3. **Fluent builder API** (from Style)
4. **Clear @moduledoc and @doc** with examples

## Implementation Plan

### Task 3.1.1: Component Behaviour

The base behaviour for all widgets. Stateless components receive props and render directly.

- [x] 3.1.1.1 Create `TermUI.Component.RenderNode` struct
- [x] 3.1.1.2 Create `TermUI.Component` module with behaviour definition
- [x] 3.1.1.3 Define render tree types
- [x] 3.1.1.4 Implement `__using__` macro
- [x] 3.1.1.5 Define optional callbacks (describe, default_props)

### Task 3.1.2: StatefulComponent Behaviour

Extension of Component with state management for interactive widgets.

- [x] 3.1.2.1 Create `TermUI.StatefulComponent` module using Component
- [x] 3.1.2.2 Define event handling callback
- [x] 3.1.2.3 Override render callback signature (state instead of props)
- [x] 3.1.2.4 Define optional lifecycle callbacks (terminate, handle_info, handle_call)
- [x] 3.1.2.5 Implement `__using__` macro with GenServer integration

### Task 3.1.3: Container Behaviour

Extension of StatefulComponent for widgets managing children.

- [x] 3.1.3.1 Create `TermUI.Container` module using StatefulComponent
- [x] 3.1.3.2 Define child specification types
- [x] 3.1.3.3 Define layout callback
- [x] 3.1.3.4 Implement default child lifecycle management
- [x] 3.1.3.5 Implement `__using__` macro with child helpers

### Task 3.1.4: Behaviour Helpers

Common utilities used across all component types.

- [x] 3.1.4.1 Implement `props!/2` macro for prop validation
- [x] 3.1.4.2 Implement render tree builder functions (text, styled, box, stack)
- [x] 3.1.4.3 Implement style merging utility
- [x] 3.1.4.4 Implement size computation helper

### Unit Tests - Section 3.1

#### Component Behaviour Tests
- [x] Test Component behaviour can be implemented with just render callback
- [x] Test __using__ macro injects default implementations correctly
- [x] Test render callback receives correct props and area
- [x] Test describe/0 optional callback works when implemented
- [x] Test default_props/0 merges with passed props

#### StatefulComponent Behaviour Tests
- [x] Test StatefulComponent behaviour validates required callbacks
- [x] Test init/1 receives props and returns initial state
- [x] Test handle_event/2 receives events and returns updated state
- [x] Test render/2 receives state and area
- [x] Test commands from handle_event are collected properly
- [x] Test optional callbacks work when implemented

#### Container Behaviour Tests
- [x] Test Container behaviour children/1 callback returns valid child specs
- [x] Test layout/3 callback receives children and area
- [x] Test default layout implementation stacks children
- [x] Test child_spec with and without explicit id

#### Helpers Tests
- [x] Test props! macro validates required props
- [x] Test props! macro applies default values
- [x] Test props! macro raises on type mismatch
- [x] Test render tree builders produce correct nodes
- [x] Test merge_styles/2 correctly combines style sources
- [x] Test compute_size/2 calculates dimensions correctly

## Success Criteria

1. **Component behaviour** can be implemented with just `render/2` callback
2. **StatefulComponent behaviour** properly validates init, handle_event, render callbacks
3. **Container behaviour** correctly defines child management interface
4. **`__using__` macros** inject correct defaults and imports
5. **`props!` macro** validates types and applies defaults
6. **Render tree builders** produce correct node structures
7. **Style merging** follows CSS cascade rules
8. All unit tests pass
9. Documentation complete with examples

## Current Status

**Status**: Complete

### Summary
- All tasks completed
- 134 new tests added
- Total project tests: 943
- All tests passing

### How to Run
```bash
mix test test/term_ui/component_test.exs
mix test test/term_ui/stateful_component_test.exs
mix test test/term_ui/container_test.exs
mix test test/term_ui/component/helpers_test.exs
```

## Notes

### Design Considerations

- **Behaviour vs Protocol**: Using behaviours over protocols because we want to define GenServer integration and default implementations via __using__ macros
- **Render tree immutability**: Render trees are data structures, not live processes - enables efficient diffing
- **Command pattern**: Side effects return commands rather than executing directly - enables testing and predictable behavior

### Integration with Phase 2

- RenderNode will be converted to Buffer cells by the renderer
- Styles use existing Style module from renderer
- Area/rect type uses simple map for now (layout system comes in Phase 4)

### Future Considerations

- Consider adding `should_update?/2` callback for render optimization
- May need `receive_props/2` for controlled component pattern
- Focus integration will come in Section 3.4
- Event routing will use these behaviours in Section 3.3
