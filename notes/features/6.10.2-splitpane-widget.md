# Feature: Section 6.10.2 SplitPane Widget

## Problem Statement

Applications need flexible multi-pane layouts where users can resize sections dynamically (like IDE editors with sidebars, file explorers with preview panels, or terminal multiplexers). TermUI currently lacks a widget for creating resizable split layouts.

## Solution Overview

Implement a SplitPane widget that divides space between two or more panes with:
- Horizontal and vertical split orientations
- Draggable dividers (keyboard and mouse)
- Min/max size constraints per pane
- Collapsible panes
- Nested splits for complex layouts
- Layout state persistence

## Requirements (from Phase 6 Planning)

### 6.10.2 SplitPane Widget

- [x] 6.10.2.1 Implement horizontal split with two panes
- [x] 6.10.2.2 Implement vertical split with two panes
- [x] 6.10.2.3 Implement draggable divider (keyboard and mouse)
- [x] 6.10.2.4 Implement min/max size constraints per pane
- [x] 6.10.2.5 Implement collapse to zero (hide pane)
- [x] 6.10.2.6 Implement nested splits for complex layouts
- [x] 6.10.2.7 Implement layout state persistence

## Technical Design

### Split Orientation

```elixir
@type orientation :: :horizontal | :vertical

# Horizontal: panes side by side (left | right)
# Vertical: panes stacked (top / bottom)
```

### Pane Structure

```elixir
@type pane :: %{
  id: term(),                    # Unique identifier
  content: render_node(),        # Render content for this pane
  min_size: integer() | nil,     # Minimum size in characters/lines
  max_size: integer() | nil,     # Maximum size in characters/lines
  collapsed: boolean(),          # Whether pane is collapsed
  size: integer() | float()      # Size in chars or ratio (0.0-1.0)
}
```

### Props

```elixir
SplitPane.new(
  orientation: :horizontal | :vertical,
  panes: [pane_spec()],          # Pane definitions
  divider_size: 1,               # Divider thickness (default: 1)
  divider_style: Style.t(),      # Divider appearance
  resizable: true,               # Whether dividers can be dragged
  on_resize: fn sizes -> ... end,# Callback on resize
  on_collapse: fn id -> ... end, # Callback on collapse
  persist_key: atom() | nil      # Key for layout persistence
)
```

### State

```elixir
%{
  orientation: :horizontal | :vertical,
  panes: [pane()],               # Pane states with calculated sizes
  divider_size: integer(),
  divider_style: Style.t(),
  resizable: boolean(),
  focused_divider: integer() | nil,  # Which divider has focus (0-indexed)
  dragging: boolean(),           # Whether currently dragging
  drag_start: integer() | nil,   # Drag start position
  on_resize: function() | nil,
  on_collapse: function() | nil,
  persist_key: atom() | nil,
  total_size: integer()          # Total available size
}
```

### Keyboard Controls

| Key | Action |
|-----|--------|
| Tab | Move focus between dividers |
| Left/Up | Move divider left/up (decrease pane before) |
| Right/Down | Move divider right/down (increase pane before) |
| Shift+Left/Up | Move divider by larger step |
| Shift+Right/Down | Move divider by larger step |
| Enter | Toggle collapse of pane after divider |
| Home | Move divider to minimum position |
| End | Move divider to maximum position |

### Mouse Controls

- Click on divider: Start drag
- Drag divider: Resize panes
- Double-click divider: Toggle collapse

### Rendering

Horizontal split:
```
┌─────────────┬─────────────┐
│             │             │
│  Pane 1     │  Pane 2     │
│             │             │
│             │             │
└─────────────┴─────────────┘
              ^ divider
```

Vertical split:
```
┌─────────────────────────────┐
│         Pane 1              │
├─────────────────────────────┤  <- divider
│         Pane 2              │
└─────────────────────────────┘
```

### Divider Characters

```elixir
# Horizontal orientation (vertical divider)
│  # standard
┃  # focused/dragging

# Vertical orientation (horizontal divider)
─  # standard
━  # focused/dragging
```

### Size Calculation

1. Calculate total available space
2. Subtract space for dividers
3. Distribute remaining space based on pane sizes:
   - Float values (0.0-1.0): proportional allocation
   - Integer values: fixed allocation
4. Apply min/max constraints
5. Redistribute overflow/underflow

## Implementation Plan

### Step 1: Core Structure (6.10.2.1, 6.10.2.2)
- [x] Create `lib/term_ui/widgets/split_pane.ex`
- [x] Define types and helper functions
- [x] Implement `new/1` for props creation
- [x] Implement `init/1` for state initialization
- [x] Implement basic horizontal split rendering
- [x] Implement basic vertical split rendering

### Step 2: Size Calculation
- [x] Implement size distribution algorithm
- [x] Handle proportional sizes (floats)
- [x] Handle fixed sizes (integers)
- [x] Handle mixed size specifications

### Step 3: Keyboard Navigation (6.10.2.3)
- [x] Implement Tab to focus dividers
- [x] Implement arrow keys for resize
- [x] Implement Shift+arrows for larger steps
- [x] Implement Home/End for min/max position

### Step 4: Mouse Interaction (6.10.2.3)
- [x] Implement click to start drag
- [x] Implement drag to resize
- [x] Implement release to end drag
- [x] Implement double-click to toggle collapse

### Step 5: Size Constraints (6.10.2.4)
- [x] Implement min_size enforcement
- [x] Implement max_size enforcement
- [x] Handle constraint violations gracefully

### Step 6: Pane Collapse (6.10.2.5)
- [x] Implement collapse state
- [x] Implement Enter to toggle collapse
- [x] Implement double-click to toggle
- [x] Hide collapsed pane, expand adjacent
- [x] Show collapse indicator

### Step 7: Nested Splits (6.10.2.6)
- [x] Support SplitPane as pane content
- [x] Handle focus propagation
- [x] Handle event bubbling

### Step 8: Layout Persistence (6.10.2.7)
- [x] Define persistence format
- [x] Implement `get_layout/1` to export state
- [x] Implement `set_layout/2` to restore state
- [x] Document persistence API

### Step 9: Tests
- [x] Test horizontal split renders correctly
- [x] Test vertical split renders correctly
- [x] Test keyboard resize works
- [x] Test mouse drag resize works
- [x] Test min/max constraints enforced
- [x] Test collapse/expand works
- [x] Test nested splits work
- [x] Test layout persistence

### Step 10: Example Application
- [x] Create `examples/split_pane/` directory
- [x] Implement IDE-style layout demo
- [x] Show nested splits
- [x] Demonstrate all features

## Success Criteria

- [x] SplitPane renders panes with correct sizes
- [x] Both horizontal and vertical orientations work
- [x] Dividers can be moved with keyboard
- [x] Dividers can be dragged with mouse
- [x] Min/max constraints are enforced
- [x] Panes can be collapsed and expanded
- [x] Nested splits work correctly
- [x] Layout can be saved and restored
- [x] All tests pass (45 tests)
- [x] Example application demonstrates features

## Current Status

**Status**: COMPLETED

**What Works**:
- SplitPane widget fully implemented
- All 7 requirements from Phase 6 planning met
- 45 comprehensive tests passing
- Example application demonstrating IDE-style layout

**Files Created**:
- `lib/term_ui/widgets/split_pane.ex` (~820 lines)
- `test/term_ui/widgets/split_pane_test.exs` (45 tests)
- `examples/split_pane/` (example application)
- `notes/summaries/6.10.2-splitpane-widget-summary.md`

**Test Coverage**:
- 45 tests covering all features
- Pane constructors, initialization, rendering
- Keyboard navigation, Tab cycling
- Mouse drag and double-click
- Size constraints (min/max)
- Collapse/expand functionality
- Nested splits
- Layout persistence (get_layout/set_layout)
- Public API functions
- Edge cases
