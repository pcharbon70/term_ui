# Feature 1.3: Escape Sequence Parser

## Problem Statement

TermUI needs to parse raw terminal input bytes into structured events (key presses, mouse actions, paste content, focus changes). Without a parser, the framework cannot interpret user input for interactive TUI applications.

### Impact
- Foundation for all user input handling in TermUI
- Required for keyboard navigation, mouse interaction, text input
- Enables proper handling of special keys, modifiers, and mouse events
- Used by Phase 3 (Component System) and Phase 5 (Event System)

## Solution Overview

Implement a state machine parser that transforms raw bytes into semantic events, handling:
- Single characters and control codes
- Escape sequences for special keys
- Mouse events (X10 and SGR formats)
- Bracketed paste content
- Focus events

### Key Design Decisions
1. **State machine approach** - Handle variable-length sequences correctly
2. **Incremental parsing** - Support split sequences across read boundaries
3. **Event structs** - Type-safe, pattern-matchable event representations
4. **No timeout in core parser** - Caller handles timeout for ESC disambiguation

## Technical Details

### Module Structure
```
lib/term_ui/
├── parser.ex           # Main parser module with state machine
└── parser/
    ├── events.ex       # Event struct definitions
    └── sequences.ex    # Key sequence mappings
```

### Event Types
- `KeyEvent` - Keyboard input with modifiers
- `MouseEvent` - Mouse clicks, releases, motion
- `PasteEvent` - Bracketed paste content
- `FocusEvent` - Focus gained/lost

### Parser States
- `:ground` - Normal input processing
- `:escape` - Received ESC, waiting for more
- `:csi` - In CSI sequence (ESC[)
- `:csi_param` - Collecting CSI parameters
- `:ss3` - In SS3 sequence (ESCO)
- `:mouse_x10` - Collecting X10 mouse bytes
- `:mouse_sgr` - Collecting SGR mouse parameters
- `:paste` - Accumulating paste content

## Success Criteria

1. ✅ All event structs defined with proper types
2. ✅ Single characters parse correctly
3. ✅ Ctrl+key combinations work
4. ✅ Arrow keys and function keys parse correctly
5. ✅ Modified keys (Ctrl+Shift+Up) work
6. ✅ X10 and SGR mouse events parse correctly
7. ✅ Bracketed paste accumulates content
8. ✅ Parser state persists across calls
9. ✅ Comprehensive test coverage

## Implementation Plan

### Phase 1: Event Data Structures (1.3.1)
- [ ] Define KeyEvent struct
- [ ] Define MouseEvent struct
- [ ] Define PasteEvent struct
- [ ] Define FocusEvent struct

### Phase 2: State Machine Core (1.3.2)
- [ ] Define parser state struct
- [ ] Implement state transitions
- [ ] Implement parameter accumulation
- [ ] Implement parse/2 main function

### Phase 3: Key Sequence Recognition (1.3.3)
- [ ] Map arrow key sequences
- [ ] Map function key sequences (F1-F12)
- [ ] Map special keys (Home, End, etc.)
- [ ] Handle modifier parameters

### Phase 4: Mouse Event Parsing (1.3.4)
- [ ] Implement X10 mouse parsing
- [ ] Implement SGR mouse parsing
- [ ] Decode button values
- [ ] Extract modifiers

### Phase 5: Bracketed Paste (1.3.5)
- [ ] Detect paste start sequence
- [ ] Accumulate paste content
- [ ] Detect paste end sequence

### Phase 6: Testing
- [ ] Test single character parsing
- [ ] Test control characters
- [ ] Test arrow keys and function keys
- [ ] Test mouse events
- [ ] Test bracketed paste
- [ ] Test split sequences

## Key Sequence Reference

### Arrow Keys
- Up: `ESC[A` or `ESCOA`
- Down: `ESC[B` or `ESCOB`
- Left: `ESC[D` or `ESCOD`
- Right: `ESC[C` or `ESCOC`

### With Modifiers (CSI format)
- `ESC[1;2A` = Shift+Up
- `ESC[1;3A` = Alt+Up
- `ESC[1;5A` = Ctrl+Up
- `ESC[1;7A` = Ctrl+Alt+Up

### Function Keys
- F1-F4: `ESCOP` through `ESCOS` (SS3)
- F5-F12: `ESC[15~` through `ESC[24~` (CSI)

### Special Keys
- Home: `ESC[H` or `ESC[1~`
- End: `ESC[F` or `ESC[4~`
- Insert: `ESC[2~`
- Delete: `ESC[3~`
- PageUp: `ESC[5~`
- PageDown: `ESC[6~`

### Mouse Events
- X10: `ESC[M` + button + col + row (each +32)
- SGR: `ESC[<button;col;rowM` (press) or `m` (release)

### Bracketed Paste
- Start: `ESC[200~`
- End: `ESC[201~`

## Notes/Considerations

### Modifier Encoding
CSI modifier parameter: `1 + (shift?1:0) + (alt?2:0) + (ctrl?4:0) + (meta?8:0)`
- 2 = Shift
- 3 = Alt
- 4 = Shift+Alt
- 5 = Ctrl
- 6 = Ctrl+Shift
- 7 = Ctrl+Alt
- 8 = Ctrl+Shift+Alt

### Button Encoding (X10)
- `button & 3`: 0=left, 1=middle, 2=right, 3=release
- `button & 4`: Shift held
- `button & 8`: Alt held
- `button & 16`: Ctrl held
- `button & 32`: Motion event
- `button & 64`: Scroll wheel

### Timeout Handling
The parser itself doesn't handle timeouts - caller should:
1. Call parse with available bytes
2. If parser returns with :escape state and no more bytes, wait ~50ms
3. If timeout expires, flush ESC as key event

## Current Status

**Status**: Planning Complete - Ready for Implementation

### What Works
- N/A - Implementation not started

### What's Next
- Create event struct definitions
- Implement parser state machine

### How to Run
```bash
cd /home/ducky/code/term_ui
mix test test/term_ui/parser_test.exs
```
