# Feature Plan: 2.2 ETS-Based Double Buffering

## Problem Statement

The rendering engine needs to manage two screen buffers for efficient differential updates. Components write to the "current" buffer while the renderer compares against the "previous" buffer to identify changes. After rendering, the buffers swap roles. This double-buffering pattern prevents visual tearing and enables the diff algorithm to work correctly.

We need:
- A BufferManager GenServer to own and coordinate both buffers
- Atomic buffer swapping without content copying
- Concurrent write support for multiple component processes
- Proper lifecycle management (resize, cleanup)

## Solution Overview

Implement a BufferManager GenServer that owns two ETS-based buffers and provides:
1. Current buffer access for component writes
2. Atomic buffer swapping after render
3. Resize handling with content preservation
4. Proper cleanup on termination

### Key Design Decisions

- **GenServer owns ETS tables** - Ensures cleanup when process dies
- **Atomic swap by reference** - Swap buffer references, not content
- **Public ETS access** - Components write directly without message passing
- **Atomics for dirty flag** - Lock-free concurrent dirty tracking

## Technical Details

### File Structure
```
lib/term_ui/renderer/
├── buffer.ex           # (existing from 2.1)
├── buffer_manager.ex   # NEW: GenServer managing double buffers

test/term_ui/renderer/
├── buffer_test.exs          # (existing from 2.1)
├── buffer_manager_test.exs  # NEW: Tests for buffer manager
```

### Dependencies
- Section 2.1 complete (Buffer module)
- `:atomics` module for dirty flag

## Implementation Plan

### Task 2.2.1: Buffer Manager GenServer ✅
- [x] 2.2.1.1 Define `TermUI.Renderer.BufferManager` GenServer module
- [x] 2.2.1.2 Implement `init/1` creating two buffers based on dimensions
- [x] 2.2.1.3 Implement `get_current_buffer/0` returning current buffer reference
- [x] 2.2.1.4 Implement `get_previous_buffer/0` returning previous buffer reference
- [x] 2.2.1.5 Implement `swap_buffers/0` atomically swapping current and previous

### Task 2.2.2: Concurrent Write Support ✅
- [x] 2.2.2.1 Verify concurrent cell writes work with ETS `:public` access
- [x] 2.2.2.2 Document concurrency semantics (last-writer-wins, no ordering)
- [x] 2.2.2.3 Implement `set_cells/1` batch write through manager
- [x] 2.2.2.4 Test concurrent writes from multiple processes

### Task 2.2.3: Buffer Initialization and Clearing ✅
- [x] 2.2.3.1 Implement `clear_current/0` clearing entire current buffer
- [x] 2.2.3.2 Implement `clear_row/1` for single-row reset
- [x] 2.2.3.3 Implement `clear_region/4` for rectangular region reset
- [x] 2.2.3.4 Both buffers initialized to empty on start

### Task 2.2.4: Buffer Lifecycle Management ✅
- [x] 2.2.4.1 Implement `terminate/2` callback deleting both ETS tables
- [x] 2.2.4.2 Implement `resize/2` reallocating both buffers with content preservation
- [x] 2.2.4.3 Implement dimension query `dimensions/0`
- [x] 2.2.4.4 Handle resize during operations gracefully

### Task 2.2.5: Dirty Flag Management ✅
- [x] 2.2.5.1 Implement atomic dirty flag using `:atomics`
- [x] 2.2.5.2 Implement `mark_dirty/0` setting flag on buffer modification
- [x] 2.2.5.3 Implement `clear_dirty/0` resetting flag after render
- [x] 2.2.5.4 Implement `dirty?/0` checking flag state

### Unit Tests ✅
- [x] Test buffer manager creates two buffers on init
- [x] Test get_current_buffer returns valid buffer
- [x] Test get_previous_buffer returns valid buffer
- [x] Test swap_buffers exchanges buffer references
- [x] Test concurrent writes from multiple processes don't corrupt
- [x] Test batch write updates multiple cells
- [x] Test clear operations reset cells to empty
- [x] Test resize preserves content and updates dimensions
- [x] Test terminate cleans up ETS tables
- [x] Test dirty flag operations (mark, clear, query)

## Success Criteria

1. BufferManager GenServer starts and creates two buffers
2. Buffer swapping is atomic (reference swap, not content copy)
3. Concurrent writes from multiple processes work correctly
4. Resize preserves content within new dimensions
5. Cleanup deletes both ETS tables on termination
6. Dirty flag provides lock-free concurrent access
7. All unit tests pass
8. Credo strict mode passes

## Current Status

**Status**: ✅ Complete

### What Works
- BufferManager GenServer with double buffering
- Atomic buffer swap by reference exchange
- Concurrent write support with ETS public access
- Dirty flag using :atomics for lock-free access
- Resize with content preservation
- Proper cleanup on termination
- 47 unit tests passing

### What's Next
- Section 2.3: Diff Algorithm

### How to Run
```bash
mix test test/term_ui/renderer/buffer_manager_test.exs
mix credo --strict
```

## Notes

- Buffer swap is O(1) - just swaps references, no content copying
- Dirty flag uses `:atomics` for lock-free concurrent access from any process
- ETS `:public` access allows components to write without GenServer message passing
- Manager tracks which buffer is current via state, not buffer content
