# Feature Plan: 4.6 Theme System

## Problem Statement

Applications need consistent visual presentation across all components with the ability to switch appearances at runtime. Without a theme system:
- Colors and styles must be hardcoded in each component
- No way to switch between light/dark modes
- User customization is impossible
- Accessibility themes cannot be supported
- Visual consistency requires manual coordination

The theme system provides application-wide visual consistency and runtime appearance switching.

## Solution Overview

Implement a comprehensive theme system supporting:
- **Theme Structure** - Hierarchical definition of colors and component styles
- **Built-in Themes** - Default dark, light, and high-contrast themes
- **Theme Loading** - Load from configuration with validation
- **Runtime Switching** - Change themes without restart
- **Theme-Aware Components** - Components automatically use theme values

### Key Design Decisions

- **GenServer for theme state** - Central theme management with subscriptions
- **ETS for fast reads** - Components read theme values without GenServer calls
- **Style integration** - Themes produce Style structs for components
- **Partial themes** - Override only specific values, inherit rest from defaults
- **Process-based notifications** - PubSub pattern for theme change events

## Technical Details

### File Structure

```
lib/term_ui/
├── style.ex                    # Style module (completed)
└── theme.ex                    # Theme system

test/term_ui/
└── theme_test.exs              # Theme tests
```

### Dependencies

- Section 4.5 Style System (completed)
- Will be used by all widgets for visual styling
- Will integrate with Application for startup

## Implementation Plan

### Task 4.6.1: Theme Structure

Define the theme struct and color/style organization.

- [x] 4.6.1.1 Define Theme struct with colors, semantic, and component sections
- [x] 4.6.1.2 Define color section (background, foreground, primary, secondary, accent)
- [x] 4.6.1.3 Define semantic colors (success, warning, error, info, muted)
- [x] 4.6.1.4 Define component section with per-widget style defaults

### Task 4.6.2: Built-in Themes

Provide ready-to-use themes.

- [x] 4.6.2.1 Implement default dark theme
- [x] 4.6.2.2 Implement light theme
- [x] 4.6.2.3 Implement high-contrast theme for accessibility
- [x] 4.6.2.4 Implement theme retrieval by name

### Task 4.6.3: Theme Loading

Load and validate themes from configuration.

- [x] 4.6.3.1 Implement theme loading from keyword list or map
- [x] 4.6.3.2 Implement theme validation checking required fields
- [x] 4.6.3.3 Implement partial theme merge with default theme
- [x] 4.6.3.4 Implement helpful error messages for invalid themes

### Task 4.6.4: Runtime Theme Switching

Support changing themes at runtime.

- [x] 4.6.4.1 Implement GenServer for theme state management
- [x] 4.6.4.2 Implement ETS table for fast theme reads
- [x] 4.6.4.3 Implement set_theme/1 changing active theme
- [x] 4.6.4.4 Implement subscribe/0 for theme change notifications
- [x] 4.6.4.5 Implement get_theme/0 returning current theme

### Task 4.6.5: Theme-Aware Components

Enable components to use theme values automatically.

- [x] 4.6.5.1 Implement get_color/1 for retrieving theme colors
- [x] 4.6.5.2 Implement get_semantic/1 for semantic colors
- [x] 4.6.5.3 Implement get_component_style/1 for component defaults
- [x] 4.6.5.4 Implement style_from_theme/2 combining theme with overrides

### Unit Tests

- [x] Test theme structure contains all required sections
- [x] Test built-in themes load correctly
- [x] Test theme loading from configuration
- [x] Test invalid theme produces helpful error
- [x] Test partial theme merges with defaults
- [x] Test theme switching updates ETS
- [x] Test subscribers receive theme change notifications
- [x] Test get_color/get_semantic return correct values
- [x] Test component styles resolve correctly

## Success Criteria

1. Theme struct defines complete visual appearance
2. Built-in themes (dark, light, high-contrast) work correctly
3. Partial themes merge properly with defaults
4. Runtime switching updates all theme readers
5. Subscribers notified of theme changes
6. Component style resolution works correctly
7. All unit tests pass

## Current Status

**Status**: Complete

### How to Run
```bash
mix test test/term_ui/theme_test.exs
```

## Notes

### Theme Structure

```elixir
%Theme{
  name: :dark,
  colors: %{
    background: :black,
    foreground: :white,
    primary: :blue,
    secondary: :cyan,
    accent: :magenta
  },
  semantic: %{
    success: :green,
    warning: :yellow,
    error: :red,
    info: :cyan,
    muted: :bright_black
  },
  components: %{
    button: %{normal: style, focused: style, disabled: style},
    text_input: %{normal: style, focused: style, disabled: style},
    ...
  }
}
```

### Example Usage

```elixir
alias TermUI.Theme

# Start theme server
Theme.start_link(theme: :dark)

# Get current theme
theme = Theme.get_theme()

# Switch themes
Theme.set_theme(:light)

# Subscribe to changes
Theme.subscribe()
receive do
  {:theme_changed, new_theme} -> # re-render
end

# Get colors
bg = Theme.get_color(:background)
error = Theme.get_semantic(:error)

# Get component style
button_style = Theme.get_component_style(:button, :focused)
```
