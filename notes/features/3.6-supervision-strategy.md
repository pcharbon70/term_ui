# Feature Plan: 3.6 Supervision Strategy

## Problem Statement

Component processes need fault isolation and recovery mechanisms. Without proper supervision:
- A crash in one widget brings down the entire UI
- No automatic recovery from transient failures
- No graceful shutdown coordination
- Difficult to debug and monitor component state

The supervision strategy must leverage OTP's battle-tested patterns while providing TUI-specific features like state recovery and tree introspection.

## Solution Overview

Implement a supervision system mirroring the UI component hierarchy:
- DynamicSupervisor for dynamic component trees
- Configurable restart strategies per component
- Graceful shutdown with timeouts
- State persistence to ETS for crash recovery
- Introspection tools for debugging

### Key Design Decisions

- **DynamicSupervisor over Supervisor** - Components are added/removed at runtime
- **Transient restart by default** - Only restart on abnormal termination
- **ETS for state persistence** - Crash-safe, fast access
- **Container-level supervision** - Containers supervise their children for natural fault boundaries

## Technical Details

### File Structure

```
lib/term_ui/
├── component_supervisor.ex      # Main supervisor module
├── component/
│   ├── state_persistence.ex     # ETS state persistence
│   └── introspection.ex         # Tree visualization and metrics

test/term_ui/
├── component_supervisor_test.exs
├── component/
│   ├── state_persistence_test.exs
│   └── introspection_test.exs
```

### Dependencies

- Section 3.1 (Component behaviours)
- Section 3.2 (Component lifecycle)
- Existing GenServer/DynamicSupervisor infrastructure

### State Persistence Schema

```elixir
# ETS table structure
:term_ui_component_states
- key: component_id
- value: %{
    state: term(),
    props: map(),
    persisted_at: DateTime.t()
  }
```

## Implementation Plan

### Task 3.6.1: Component Supervisor

Application-level DynamicSupervisor managing all widget processes.

- [x] 3.6.1.1 Implement `TermUI.ComponentSupervisor` as DynamicSupervisor
- [x] 3.6.1.2 Implement `start_component/2` spawning component under supervisor
- [x] 3.6.1.3 Implement `stop_component/1` terminating component and children
- [x] 3.6.1.4 Implement container-level supervision (containers supervise their children)
- [x] 3.6.1.5 Implement component registry for lookup by ID

### Task 3.6.2: Restart Strategies

Configurable restart behavior for different component types.

- [x] 3.6.2.1 Implement `:transient` restart (default) - restart on crash only
- [x] 3.6.2.2 Implement `:permanent` restart option - always restart
- [x] 3.6.2.3 Implement `:temporary` restart option - never restart
- [x] 3.6.2.4 Implement restart intensity limits (max_restarts, max_seconds)
- [x] 3.6.2.5 Implement child spec generation with restart strategy

### Task 3.6.3: Shutdown Coordination

Graceful shutdown with proper cleanup sequencing.

- [x] 3.6.3.1 Implement shutdown timeout configuration (default 5000ms)
- [x] 3.6.3.2 Implement shutdown order - children before parents
- [x] 3.6.3.3 Implement forced shutdown (brutal_kill) after timeout
- [x] 3.6.3.4 Implement shutdown hooks for cleanup actions
- [x] 3.6.3.5 Implement cascade shutdown for container trees

### Task 3.6.4: Fault Recovery

State persistence and recovery after crashes.

- [x] 3.6.4.1 Implement `TermUI.Component.StatePersistence` module
- [x] 3.6.4.2 Implement ETS table for state storage
- [x] 3.6.4.3 Implement `persist_state/2` saving state before crash
- [x] 3.6.4.4 Implement `recover_state/1` restoring state on restart
- [x] 3.6.4.5 Implement recovery mode props: `:reset`, `:last_props`, `:last_state`
- [x] 3.6.4.6 Implement crash notification to parent containers

### Task 3.6.5: Supervision Introspection

Debugging and monitoring tools.

- [x] 3.6.5.1 Implement `TermUI.Component.Introspection` module
- [x] 3.6.5.2 Implement `get_component_tree/0` returning tree structure
- [x] 3.6.5.3 Implement `get_component_info/1` returning state and metrics
- [x] 3.6.5.4 Implement supervision metrics: restart_count, uptime, child_count
- [x] 3.6.5.5 Implement tree visualization (text representation)

### Unit Tests - Section 3.6

- [x] Test components spawn under correct supervisor
- [x] Test crashed component restarts with :transient strategy
- [x] Test normally-exited component doesn't restart with :transient
- [x] Test :permanent strategy always restarts
- [x] Test :temporary strategy never restarts
- [x] Test restart limits trigger supervisor shutdown when exceeded
- [x] Test shutdown terminates children before parent
- [x] Test forced shutdown kills component after timeout
- [x] Test state persists to ETS before crash
- [x] Test state recovery restores persisted state after restart
- [x] Test crash notification reaches parent container
- [x] Test tree introspection returns correct structure
- [x] Test component metrics are accurate

## API Design

### ComponentSupervisor

```elixir
# Start a component
{:ok, pid} = ComponentSupervisor.start_component(MyWidget, %{
  id: :my_widget,
  restart: :transient,
  shutdown: 5000,
  recovery: :last_state
})

# Stop a component
:ok = ComponentSupervisor.stop_component(:my_widget)

# List all components
components = ComponentSupervisor.list_components()
```

### State Persistence

```elixir
# Persist state (called automatically on state change)
StatePersistence.persist(:my_widget, state)

# Recover state (called in init)
case StatePersistence.recover(:my_widget) do
  {:ok, state} -> {:ok, state}
  :not_found -> {:ok, initial_state}
end

# Clear persisted state
StatePersistence.clear(:my_widget)
```

### Introspection

```elixir
# Get tree structure
tree = Introspection.get_component_tree()
# => %{
#   id: :root,
#   pid: #PID<0.123.0>,
#   children: [
#     %{id: :panel, pid: #PID<0.124.0>, children: [...]},
#     %{id: :button, pid: #PID<0.125.0>, children: []}
#   ]
# }

# Get component info
info = Introspection.get_component_info(:my_widget)
# => %{
#   pid: #PID<0.123.0>,
#   state: %{...},
#   restart_count: 2,
#   uptime_ms: 45000,
#   child_count: 3
# }

# Visualize tree
Introspection.print_tree()
# root (#PID<0.123.0>)
# ├── panel (#PID<0.124.0>)
# │   ├── label (#PID<0.125.0>)
# │   └── button (#PID<0.126.0>)
# └── status (#PID<0.127.0>)
```

## Success Criteria

1. Components spawn under DynamicSupervisor correctly
2. Restart strategies work as specified (transient, permanent, temporary)
3. Restart limits prevent restart storms
4. Shutdown coordination follows children-before-parent order
5. State persistence survives crashes and restores on restart
6. Introspection provides accurate tree structure and metrics
7. All unit tests pass
8. Documentation complete

## Current Status

**Status**: Complete

### Completed
- All 5 tasks implemented
- 59 unit tests added
- All 1357 tests pass

### How to Run
```bash
mix test test/term_ui/component_supervisor_test.exs
mix test test/term_ui/component/state_persistence_test.exs
mix test test/term_ui/component/introspection_test.exs
```

## Notes

### Implementation Order

1. ComponentSupervisor - Foundation for all other features
2. Restart Strategies - Core supervision behavior
3. State Persistence - Enables fault recovery
4. Fault Recovery - Uses state persistence
5. Shutdown Coordination - Requires supervisor infrastructure
6. Introspection - Can be built last, uses all other modules

### Restart Strategy Guidelines

- **:transient** (default) - Use for most widgets
- **:permanent** - Use for critical system components (root, event router)
- **:temporary** - Use for ephemeral dialogs, tooltips

### ETS Table Configuration

```elixir
:ets.new(:term_ui_component_states, [
  :named_table,
  :set,
  :public,
  read_concurrency: true,
  write_concurrency: true
])
```

### Integration Points

- Lifecycle (3.2): Mount/unmount trigger state persistence
- Event Router (3.3): Receives crash notifications for re-routing
- Focus Manager (3.4): Handles focus on component restart
