# Feature Plan: 4.1 Constraint Types

## Problem Statement

The layout system needs a way for components to express how they request space. Without constraint types:
- Components cannot specify fixed sizes (e.g., 20 cells wide)
- Responsive layouts that adapt to terminal size are impossible
- Proportional distribution among siblings cannot be expressed
- Complex layouts with min/max bounds are not possible

Constraint types provide the declarative vocabulary for layout requirements.

## Solution Overview

Implement constraint types that express how components request space:
- **Length** - Exact size in terminal cells
- **Percentage** - Fraction of parent container size
- **Ratio** - Proportional share of remaining space among siblings
- **Min/Max** - Bounds on other constraints
- **Fill** - Take all remaining space
- **Composition** - Combine constraints with piping

### Key Design Decisions

- **Declarative** - Constraints describe desired outcome, not how to achieve it
- **Composable** - Constraints combine sensibly (e.g., `percentage(50) |> min(10)`)
- **Pure Elixir** - No external dependencies
- **Struct-based** - Each constraint type is a struct for pattern matching

## Technical Details

### File Structure

```
lib/term_ui/layout/
├── constraint.ex           # Main constraint module with types
└── constraint/
    └── types.ex            # Individual constraint type structs (if needed)

test/term_ui/layout/
└── constraint_test.exs     # Unit tests for constraint types
```

### Dependencies

- None (first module in Phase 4)
- Will be used by Constraint Solver (Section 4.2)

## Implementation Plan

### Task 4.1.1: Length Constraint

Exact size in terminal cells.

- [x] 4.1.1.1 Define `Constraint.length(n)` returning constraint for exactly n cells
- [x] 4.1.1.2 Implement length validation ensuring non-negative integer
- [x] 4.1.1.3 Implement length constraint solving returning requested size
- [x] 4.1.1.4 Handle overflow when length exceeds available space (truncate with warning)

### Task 4.1.2: Percentage Constraint

Size as fraction of parent.

- [x] 4.1.2.1 Define `Constraint.percentage(p)` returning constraint for p% of parent (0-100)
- [x] 4.1.2.2 Implement percentage validation ensuring valid range
- [x] 4.1.2.3 Implement percentage calculation from parent size
- [x] 4.1.2.4 Handle rounding for sub-cell percentages (round to nearest integer)

### Task 4.1.3: Ratio Constraint

Proportional share of remaining space.

- [x] 4.1.3.1 Define `Constraint.ratio(r)` returning constraint for ratio r of remaining space
- [x] 4.1.3.2 Implement ratio calculation distributing space proportionally
- [x] 4.1.3.3 Handle multiple ratio constraints dividing space by ratio weights
- [x] 4.1.3.4 Handle zero remaining space when ratios can't be satisfied

### Task 4.1.4: Min/Max Constraints

Bounds on other constraints.

- [x] 4.1.4.1 Define `Constraint.min(n)` returning constraint for at least n cells
- [x] 4.1.4.2 Define `Constraint.max(n)` returning constraint for at most n cells
- [x] 4.1.4.3 Implement min/max as bounds on primary constraint
- [x] 4.1.4.4 Implement `Constraint.min_max(min, max)` for combined bounds

### Task 4.1.5: Fill Constraint

Take all remaining space.

- [x] 4.1.5.1 Define `Constraint.fill()` returning constraint for remaining space
- [x] 4.1.5.2 Implement fill as ratio(1) for consistent calculation
- [x] 4.1.5.3 Handle multiple fills distributing equally
- [x] 4.1.5.4 Handle zero remaining space returning zero for fill

### Task 4.1.6: Constraint Composition

Combine constraints with bounds.

- [x] 4.1.6.1 Implement constraint piping with `|>` for readable composition
- [x] 4.1.6.2 Implement `Constraint.with_min/2` and `with_max/2` for bounds
- [x] 4.1.6.3 Implement constraint simplification for optimization
- [x] 4.1.6.4 Document constraint composition semantics with examples

### Unit Tests

- [x] Test length constraint returns exact requested size
- [x] Test percentage constraint calculates correct fraction of parent
- [x] Test ratio constraint distributes space proportionally
- [x] Test min constraint enforces minimum size
- [x] Test max constraint enforces maximum size
- [x] Test fill constraint uses all remaining space
- [x] Test constraint composition applies bounds correctly
- [x] Test overflow handling when constraints exceed space

## Success Criteria

1. All constraint types can be constructed with clear API
2. Constraints validate inputs and provide clear errors
3. Constraints can be composed with `|>` operator
4. All unit tests pass
5. Documentation includes usage examples

## Current Status

**Status**: Complete

### How to Run
```bash
mix test test/term_ui/layout/constraint_test.exs
```

## Notes

### Constraint Struct Design

```elixir
defmodule TermUI.Layout.Constraint do
  @type t ::
    %Length{value: non_neg_integer()} |
    %Percentage{value: 0..100} |
    %Ratio{value: number()} |
    %Min{value: non_neg_integer(), constraint: t()} |
    %Max{value: non_neg_integer(), constraint: t()} |
    %Fill{}
end
```

### Example Usage

```elixir
# Fixed 20 cells
Constraint.length(20)

# 50% of parent
Constraint.percentage(50)

# 50% but at least 10 cells
Constraint.percentage(50) |> Constraint.with_min(10)

# Fill remaining space
Constraint.fill()

# 2:1 ratio with sibling
[Constraint.ratio(2), Constraint.ratio(1)]
```
