# Feature Plan: 4.2 Constraint Solver

## Problem Statement

The layout system needs to translate constraint types into concrete cell positions and sizes. Without a constraint solver:
- Components cannot be positioned within their containers
- Constraint priorities cannot be resolved when conflicts occur
- Complex layouts with nested constraints cannot be calculated
- Performance suffers without optimization for common cases

The constraint solver provides the algorithm to allocate space based on component constraints.

## Solution Overview

Implement a Cassowary-inspired constraint solver in pure Elixir that:
- **Processes constraints in priority order**: fixed → percentage → ratio/fill
- **Handles conflicts**: detects and resolves unsatisfiable constraints
- **Supports two dimensions**: horizontal and vertical layouts
- **Calculates positions**: converts sizes to positioned rectangles
- **Optimizes performance**: fast paths for common cases

### Key Design Decisions

- **Greedy multi-pass algorithm** - allocate in priority order for deterministic results
- **Pure Elixir** - no external dependencies for portability
- **Conflict resolution via priorities** - min bounds > fixed > percentage > ratio
- **Independent dimensions** - solve width and height separately

## Technical Details

### File Structure

```
lib/term_ui/layout/
├── constraint.ex           # Constraint types (already implemented)
└── solver.ex               # Constraint solver

test/term_ui/layout/
├── constraint_test.exs     # Constraint type tests (already implemented)
└── solver_test.exs         # Solver tests
```

### Dependencies

- Section 4.1 Constraint Types (completed)
- Will be used by Section 4.3 Layout Cache
- Will be used by Section 4.4 Flexbox Alignment

## Implementation Plan

### Task 4.2.1: Solver Algorithm

The core solving algorithm that processes constraints in passes.

- [x] 4.2.1.1 Implement `Solver.solve(constraints, available_space)` returning sizes list
- [x] 4.2.1.2 Implement fixed-size pass allocating length constraints
- [x] 4.2.1.3 Implement percentage pass calculating from parent size
- [x] 4.2.1.4 Implement ratio pass distributing remaining space
- [x] 4.2.1.5 Implement bounds enforcement clamping results to min/max

### Task 4.2.2: Conflict Resolution

Handle cases where constraints cannot all be satisfied.

- [x] 4.2.2.1 Implement conflict detection identifying unsatisfiable constraint sets
- [x] 4.2.2.2 Implement priority-based resolution preferring higher-priority constraints
- [x] 4.2.2.3 Implement proportional reduction shrinking constraints when over-constrained
- [x] 4.2.2.4 Emit warnings for constraint conflicts to aid debugging

### Task 4.2.3: Two-Dimensional Layout

Support both horizontal and vertical layouts.

- [x] 4.2.3.1 Implement horizontal layout solving for widths
- [x] 4.2.3.2 Implement vertical layout solving for heights
- [x] 4.2.3.3 Implement cross-axis sizing using stretch or intrinsic modes
- [x] 4.2.3.4 Implement nested layout with recursive solving

### Task 4.2.4: Position Calculation

Convert solved sizes into positioned rectangles.

- [x] 4.2.4.1 Implement position calculation from sizes and direction
- [x] 4.2.4.2 Implement gap support adding spacing between children
- [x] 4.2.4.3 Implement absolute positioning for overlay components
- [x] 4.2.4.4 Implement `solve_to_rects/2` returning positioned rectangles

### Task 4.2.5: Solver Optimization

Optimize for common cases to improve performance.

- [x] 4.2.5.1 Implement fast path for all-fixed-size layouts
- [x] 4.2.5.2 Implement fast path for single-fill layouts
- [x] 4.2.5.3 Optimize data structures using tuples in hot paths
- [x] 4.2.5.4 Benchmark solver performance

### Unit Tests

- [x] Test solver produces correct sizes for various constraint combinations
- [x] Test conflict resolution produces reasonable results with warnings
- [x] Test two-dimensional layout solves both dimensions correctly
- [x] Test position calculation produces non-overlapping rectangles
- [x] Test gap support adds correct spacing
- [x] Test optimization fast paths produce same results as general solver
- [x] Test solver performance meets targets

## Success Criteria

1. Solver correctly handles all constraint type combinations
2. Conflicts are detected and resolved with warnings
3. Both horizontal and vertical layouts produce correct results
4. Position calculation generates non-overlapping rectangles
5. Fast paths work for common cases without affecting correctness
6. All unit tests pass

## Current Status

**Status**: Complete

### How to Run
```bash
mix test test/term_ui/layout/solver_test.exs
```

## Notes

### Algorithm Overview

The solver uses a greedy multi-pass approach:

1. **Fixed pass**: Allocate all length constraints exactly as requested
2. **Percentage pass**: Calculate percentage constraints from total available space
3. **Ratio/Fill pass**: Distribute remaining space proportionally

After each pass, remaining space is updated. Bounds (min/max) are enforced at the end.

### Conflict Resolution Strategy

When constraints exceed available space:
1. Respect min bounds (highest priority)
2. Reduce ratios/fills first (lowest priority)
3. Reduce percentages proportionally
4. Only reduce fixed sizes as last resort
5. Log warning about conflict

### Example Usage

```elixir
alias TermUI.Layout.{Constraint, Solver}

# Three-pane layout: 200px sidebar, 1:2 ratio for main/detail
constraints = [
  Constraint.length(200),
  Constraint.ratio(1),
  Constraint.ratio(2)
]

# Solve for 1000px total width
sizes = Solver.solve(constraints, 1000)
# => [200, 267, 533]

# Get positioned rectangles
rects = Solver.solve_to_rects(constraints, %{x: 0, y: 0, width: 1000, height: 50})
# => [
#   %{x: 0, y: 0, width: 200, height: 50},
#   %{x: 200, y: 0, width: 267, height: 50},
#   %{x: 467, y: 0, width: 533, height: 50}
# ]
```
