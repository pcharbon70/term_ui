# Feature Plan: 2.5 Escape Sequence Batching

## Problem Statement

Each write syscall has fixed overhead. Writing escape sequences individually results in many small writes, which is inefficient. We need to batch multiple escape sequences into single write calls to:

- Reduce system call overhead
- Combine adjacent SGR sequences (style changes) into single sequences
- Ensure atomic frame updates (no partial frames visible)
- Manage memory by flushing when buffer exceeds threshold

## Solution Overview

Implement a SequenceBuffer module that:
1. Accumulates escape sequences and text in an iolist
2. Combines adjacent SGR parameters into single sequences
3. Flushes on size threshold, frame completion, or explicit request
4. Uses `IO.binwrite` for raw binary output

### Key Design Decisions

- **Iolist accumulator** - Efficient append without copying
- **Size tracking** - Flush when exceeding threshold (default 4KB)
- **SGR combining** - `ESC[1mESC[31m` → `ESC[1;31m`
- **Atomic flush** - Complete frames only

## Technical Details

### File Structure
```
lib/term_ui/renderer/
├── sequence_buffer.ex  # NEW: Escape sequence batching

test/term_ui/renderer/
├── sequence_buffer_test.exs  # NEW: Tests for sequence buffer
```

### Dependencies
- Section 2.4: CursorOptimizer producing movement sequences
- Section 2.3: Diff producing style operations

## Implementation Plan

### Task 2.5.1: Sequence Buffer ✅
- [x] 2.5.1.1 Implement iolist accumulator for efficient append
- [x] 2.5.1.2 Implement `append/2` adding sequence to buffer
- [x] 2.5.1.3 Implement size tracking for flush threshold
- [x] 2.5.1.4 Implement `flush/1` returning accumulated data and resetting

### Task 2.5.2: SGR Sequence Combining ✅
- [x] 2.5.2.1 Implement SGR accumulator collecting style parameters
- [x] 2.5.2.2 Implement combined SGR emission with all parameters
- [x] 2.5.2.3 Implement SGR delta tracking (emit only changes)
- [x] 2.5.2.4 Implement SGR reset handling

### Task 2.5.3: Flush Management ✅
- [x] 2.5.3.1 Implement size threshold flush (default 4KB)
- [x] 2.5.3.2 Implement frame completion flush
- [x] 2.5.3.3 Implement explicit flush API
- [x] 2.5.3.4 Track flush statistics (count, bytes)

### Task 2.5.4: Write Optimization ✅
- [x] 2.5.4.1 Use iolist output for efficient binary building
- [x] 2.5.4.2 Provide `to_iodata/1` for output
- [x] 2.5.4.3 Track total bytes written
- [x] 2.5.4.4 Support configurable flush threshold

### Unit Tests ✅
- [x] Test buffer accumulates data without premature writes
- [x] Test size tracking counts bytes correctly
- [x] Test flush returns all accumulated data
- [x] Test SGR combining produces single sequence
- [x] Test SGR delta only emits changed parameters
- [x] Test size threshold triggers automatic flush
- [x] Test frame completion flush writes all pending
- [x] Test statistics track correctly

## Success Criteria

1. Buffer accumulates sequences without writing until flush
2. SGR combining reduces byte output by merging parameters
3. Size threshold prevents unbounded memory growth
4. Flush returns correct accumulated data
5. Statistics track bytes and flush counts
6. All unit tests pass
7. Credo strict mode passes

## Current Status

**Status**: ✅ Complete

### What Works
- Iolist-based sequence buffer
- SGR sequence combining
- Size threshold auto-flush
- Frame completion flush
- Statistics tracking
- 38 unit tests passing

### What's Next
- Section 2.6: Framerate Limiter

### How to Run
```bash
mix test test/term_ui/renderer/sequence_buffer_test.exs
mix credo --strict
```

## Notes

- Iolists avoid copying on append - prepend and reverse on flush
- SGR combining: `ESC[1;31;4m` instead of `ESC[1mESC[31mESC[4m`
- Default flush threshold 4KB balances memory and syscall overhead
- Frame completion ensures atomic visual updates
