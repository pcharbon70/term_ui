# Feature Plan: 2.6 Framerate Limiter

## Problem Statement

The rendering engine needs to cap updates at a maximum FPS (default 60, configurable up to 120) to prevent overwhelming the terminal or wasting CPU on invisible updates. Components can request redraws at any rate, but the limiter coalesces these requests and renders at the next frame boundary. This creates smooth animation while being efficient.

## Solution Overview

Implement a FramerateLimiter GenServer that:
1. Schedules frame ticks at regular intervals using `Process.send_after/3`
2. Maintains an atomic dirty flag for concurrent access
3. Renders only when the buffer is dirty
4. Provides immediate mode for urgent updates
5. Tracks performance metrics

### Key Design Decisions

- **GenServer with timer** - Centralized frame timing control
- **Atomic dirty flag** - Lock-free concurrent access with `:atomics`
- **Drift compensation** - Adjust intervals based on actual elapsed time
- **Immediate mode** - Bypass frame timing for urgent updates
- **Performance metrics** - Track FPS, render time, skip ratio

## Technical Details

### File Structure
```
lib/term_ui/renderer/
├── framerate_limiter.ex  # NEW: Frame timing and dirty flag management

test/term_ui/renderer/
├── framerate_limiter_test.exs  # NEW: Tests for framerate limiter
```

### Dependencies
- Section 2.2: BufferManager (already has dirty flag via `:atomics`)
- Section 2.5: SequenceBuffer for output

### FPS Intervals
| FPS | Interval (ms) |
|-----|---------------|
| 30  | 33.33         |
| 60  | 16.67         |
| 120 | 8.33          |

## Implementation Plan

### Task 2.6.1: Frame Timer ✅
- [x] 2.6.1.1 Implement frame timer using `Process.send_after/3` for interval scheduling
- [x] 2.6.1.2 Implement FPS configuration allowing 30, 60, or 120 FPS settings
- [x] 2.6.1.3 Implement timer drift compensation adjusting next interval based on actual elapsed time
- [x] 2.6.1.4 Implement timer pause/resume for application backgrounding

### Task 2.6.2: Dirty Flag Management ✅
- [x] 2.6.2.1 Implement atomic dirty flag using `:atomics` module for lock-free concurrent access
- [x] 2.6.2.2 Implement `mark_dirty/0` setting flag when buffer is modified
- [x] 2.6.2.3 Implement `clear_dirty/0` resetting flag after render completes
- [x] 2.6.2.4 Implement `is_dirty?/0` checking flag for render decision

### Task 2.6.3: Render Scheduling ✅
- [x] 2.6.3.1 Implement tick handler checking dirty flag and triggering render
- [x] 2.6.3.2 Implement frame skip for clean buffers with skip counting for statistics
- [x] 2.6.3.3 Implement immediate render mode bypassing frame timing for urgent updates
- [x] 2.6.3.4 Implement frame statistics tracking actual FPS, render time, and skip ratio

### Task 2.6.4: Performance Monitoring ✅
- [x] 2.6.4.1 Implement timing instrumentation measuring each render phase duration
- [x] 2.6.4.2 Implement FPS calculation from rendered frame timestamps
- [x] 2.6.4.3 Implement performance metrics API exposing current and historical statistics
- [x] 2.6.4.4 Implement slow frame detection warning when frame time exceeds target interval

### Unit Tests ✅
- [x] Test frame timer fires at correct intervals for configured FPS
- [x] Test dirty flag is set by buffer modifications
- [x] Test dirty flag is cleared after render
- [x] Test concurrent dirty flag writes don't lose updates
- [x] Test render is triggered only when buffer is dirty
- [x] Test clean frames are skipped without rendering
- [x] Test immediate mode renders without waiting for next tick
- [x] Test performance metrics accurately reflect render times

## Success Criteria

1. Frame timer maintains consistent intervals with drift compensation
2. Dirty flag handles concurrent access correctly
3. Clean frames are skipped without rendering
4. Immediate mode bypasses frame timing
5. Performance metrics accurately track FPS and render time
6. All unit tests pass
7. Credo strict mode passes

## Current Status

**Status**: ✅ Complete

### What Works
- Frame timer with configurable FPS (30, 60, 120)
- Atomic dirty flag for concurrent access
- Drift compensation for consistent frame rate
- Pause/resume for application backgrounding
- Immediate render mode
- Performance metrics (FPS, render time, skip ratio, slow frames)
- 22 unit tests passing

### What's Next
- Section 2.7: Integration Tests

### How to Run
```bash
mix test test/term_ui/renderer/framerate_limiter_test.exs
mix credo --strict
```

## Notes

- FramerateLimiter has its own dirty flag using `:atomics` - independent from BufferManager
- Frame timing uses monotonic time for accurate measurement
- Drift compensation ensures consistent frame rate over time
- Performance monitoring helps identify bottlenecks
- Slow frame detection warns when render time exceeds target interval
