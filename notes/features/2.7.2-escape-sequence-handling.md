# Feature: Task 2.7.2 - Implement Escape Sequence Handling

**Branch:** `feature/2.7.2-escape-sequence-handling`
**Base:** `multi-renderer`
**Date:** 2025-12-05
**Status:** Complete (Documentation Task)

## Overview

Task 2.7.2 requires implementing escape sequence handling with timeout-based disambiguation. Analysis shows this is **already implemented** as part of Task 2.7.1 (`poll_event/2`), since escape sequence handling is integral to the polling implementation.

## Requirement Analysis

### Task 2.7.2 Subtasks

| Subtask | Requirement | Implementation Location |
|---------|-------------|------------------------|
| 2.7.2.1 | Detect escape character (`\e`, byte 27) as potential sequence start | `EscapeParser.partial_sequence?/1` lines 399-403 |
| 2.7.2.2 | Use short timeout (50ms) to read additional sequence bytes | `@escape_timeout 50` in `raw.ex` line 1128, used in `wait_for_escape_completion/2` |
| 2.7.2.3 | Delegate parsing to `TermUI.Terminal.EscapeParser` | `EscapeParser.parse/1` called in `try_parse_buffer/1`, `try_parse_or_continue/1`, `wait_for_escape_completion/2` |
| 2.7.2.4 | Return raw Escape key event if timeout expires (single escape press) | `emit_partial_escape/2` lines 1186-1213, returns `Event.key(:escape)` |

## Implementation Details

### Escape Detection (2.7.2.1)

The `EscapeParser.partial_sequence?/1` function detects:
- Lone ESC: `<<0x1B>>`
- CSI prefix: `<<0x1B, "[">>`
- SS3 prefix: `<<0x1B, "O">>`
- Partial CSI sequences with numbers/semicolons

```elixir
# lib/term_ui/terminal/escape_parser.ex:399-403
def partial_sequence?(<<@escape>>), do: true
def partial_sequence?(<<@escape, "[">>), do: true
def partial_sequence?(<<@escape, "[", rest::binary>>), do: partial_csi?(rest)
def partial_sequence?(<<@escape, "O">>), do: true
def partial_sequence?(_), do: false
```

### 50ms Timeout (2.7.2.2)

```elixir
# lib/term_ui/backend/raw.ex:1128
@escape_timeout 50
```

Used in `wait_for_escape_completion/2` to give escape sequences time to complete:

```elixir
task = Task.async(fn -> read_one_byte() end)
case Task.yield(task, @escape_timeout) || Task.shutdown(task) do
  ...
end
```

### EscapeParser Delegation (2.7.2.3)

`poll_event/2` delegates to `EscapeParser` at multiple points:
- `try_parse_buffer/1` - Initial buffer parsing
- `try_parse_or_continue/1` - After reading new input
- `wait_for_escape_completion/2` - During escape timeout

### Lone ESC Handling (2.7.2.4)

The `emit_partial_escape/2` function handles timeout disambiguation:

```elixir
# lib/term_ui/backend/raw.ex:1192-1195
case buffer do
  # Lone ESC
  <<0x1B>> ->
    {:ok, Event.key(:escape), %{state | input_buffer: <<>>}}
  ...
end
```

## Tests Already Passing

From Task 2.7.1, these tests verify escape handling:
- "Lone ESC emits escape key event" (timeout disambiguation)
- Arrow keys parsed from escape sequences (ESC[A, ESC[B, etc.)
- Function keys parsed (ESCOP, ESC[15~, etc.)

## Action Required

Since the implementation is complete, this task requires:

1. [x] Verify existing implementation meets all subtask requirements
2. [x] Document the implementation (this file)
3. [ ] Mark Task 2.7.2 complete in phase plan
4. [ ] Write summary

## Files Modified

| File | Changes |
|------|---------|
| `notes/planning/multi-renderer/phase-02-raw-backend.md` | Mark Task 2.7.2 complete |
| `notes/features/2.7.2-escape-sequence-handling.md` | Created (this file) |

## Verification

No new tests needed - existing tests from 2.7.1 cover escape sequence handling:

```bash
mix test test/term_ui/backend/raw_test.exs --only escape
```

The following scenarios are already tested:
- Lone ESC key → emits `:escape` event after 50ms timeout
- ESC[A → emits `:up` arrow key
- ESCOP → emits `:f1` function key
- Control sequences (Ctrl+C) → emits key with `:ctrl` modifier
