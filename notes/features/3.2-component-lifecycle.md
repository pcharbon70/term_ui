# Feature Plan: 3.2 Component Lifecycle

## Problem Statement

Components need a standardized lifecycle that manages them from creation to destruction. Without clear lifecycle semantics:
- Resource management becomes error-prone (memory leaks, unclosed handles)
- Developers can't reliably hook into component stages
- State initialization and cleanup timing is unpredictable
- The runtime can't properly coordinate component tree operations

We need to implement lifecycle stages:
1. **Init** - Create initial state from props
2. **Mount** - Component added to active tree, ready for events
3. **Update** - Props changed, state may need update
4. **Unmount** - Component removed, cleanup required

These lifecycle semantics integrate with OTP's GenServer callbacks and DynamicSupervisor for process management.

## Solution Overview

Implement a `ComponentServer` GenServer wrapper that manages component lifecycle through OTP patterns:

1. `TermUI.ComponentServer` - GenServer managing lifecycle for all component types
2. `TermUI.ComponentRegistry` - ETS-based registry for component lookup
3. Lifecycle callbacks integrated into existing behaviours
4. Hook system for simple lifecycle side-effects

### Key Design Decisions

- **GenServer wrapper** - Components run as GenServer processes with lifecycle state machine
- **DynamicSupervisor** - Components spawn under dynamic supervisor for runtime tree changes
- **ETS registry** - Fast component lookup by id for event routing
- **Commands from lifecycle** - Mount/update can return commands like handle_event
- **Prop validation before init** - Fail fast with clear errors

### Lifecycle State Machine

```
[not_started] -> init -> [initialized] -> mount -> [mounted] -> unmount -> [terminated]
                                              ^                    |
                                              |---- update --------|
```

## Technical Details

### File Structure

```
lib/term_ui/
├── component_server.ex       # GenServer lifecycle manager
├── component_registry.ex     # ETS-based component registry
├── component_supervisor.ex   # DynamicSupervisor for components
└── component/
    └── lifecycle.ex          # Lifecycle types and utilities

test/term_ui/
├── component_server_test.exs
├── component_registry_test.exs
├── component_supervisor_test.exs
└── component/
    └── lifecycle_test.exs
```

### Core Types

```elixir
# Lifecycle states
@type lifecycle_state :: :initialized | :mounted | :unmounted

# Lifecycle result types
@type init_result :: {:ok, state} | {:ok, state, [command]} | {:stop, reason}
@type mount_result :: {:ok, state} | {:ok, state, [command]} | {:stop, reason}
@type update_result :: {:ok, state} | {:ok, state, [command]}
@type unmount_result :: :ok

# Component reference
@type component_ref :: pid() | {atom(), term()}

# Hook types
@type hook :: (state -> :ok | {:error, term()})
```

### Dependencies

- Section 3.1 complete (Component behaviours)
- No external dependencies

### Callback Extensions

Add to StatefulComponent behaviour:
- `mount/1` - Called when added to active tree
- `update/2` - Called when props change
- `unmount/1` - Called before termination

## Implementation Plan

### Task 3.2.1: Initialization

Implement component spawning and initialization via DynamicSupervisor.

- [x] 3.2.1.1 Create `TermUI.ComponentSupervisor` as DynamicSupervisor
- [x] 3.2.1.2 Create `TermUI.ComponentServer` GenServer with init delegation
- [x] 3.2.1.3 Implement prop validation before initialization
- [x] 3.2.1.4 Implement init timeout handling (5000ms default)

### Task 3.2.2: Mounting

Implement mount lifecycle stage when component enters active tree.

- [x] 3.2.2.1 Add `mount/1` callback to StatefulComponent behaviour
- [x] 3.2.2.2 Implement mount triggering in ComponentServer
- [x] 3.2.2.3 Implement command execution from mount result
- [x] 3.2.2.4 Implement mount error handling with recovery

### Task 3.2.3: Updates

Implement prop change detection and update callback.

- [x] 3.2.3.1 Add `update/2` callback to StatefulComponent behaviour
- [x] 3.2.3.2 Implement prop change detection via shallow comparison
- [x] 3.2.3.3 Implement selective update (only when props differ)
- [x] 3.2.3.4 Implement prop diffing utility for debugging

### Task 3.2.4: Unmounting

Implement cleanup when component removed from tree.

- [x] 3.2.4.1 Add `unmount/1` callback to StatefulComponent behaviour
- [x] 3.2.4.2 Implement unmount triggering on component removal
- [x] 3.2.4.3 Implement cleanup in GenServer terminate callback
- [x] 3.2.4.4 Implement graceful unmount with timeout (5000ms)

### Task 3.2.5: Component Registry

Implement ETS-based registry for component lookup.

- [x] 3.2.5.1 Create `TermUI.ComponentRegistry` module
- [x] 3.2.5.2 Implement register/unregister on mount/unmount
- [x] 3.2.5.3 Implement lookup by id and by pid
- [x] 3.2.5.4 Implement list all components

### Task 3.2.6: Lifecycle Hooks

Implement hook system for simple lifecycle side-effects.

- [x] 3.2.6.1 Implement hook registration in component state
- [x] 3.2.6.2 Implement `after_mount` hook
- [x] 3.2.6.3 Implement `before_unmount` hook
- [x] 3.2.6.4 Implement `on_prop_change` hook

### Unit Tests - Section 3.2

#### Initialization Tests
- [x] Test component initialization creates process with correct state
- [x] Test invalid props fail initialization with descriptive error
- [x] Test init timeout stops slow initialization
- [x] Test init can return commands

#### Mount Tests
- [x] Test mount callback called after component added to tree
- [x] Test mount commands are executed
- [x] Test mount error triggers appropriate handling
- [x] Test mount not called if init fails

#### Update Tests
- [x] Test update callback receives new props when changed
- [x] Test update not called when props unchanged
- [x] Test update can return commands
- [x] Test prop diffing detects changes correctly

#### Unmount Tests
- [x] Test unmount callback called when component removed
- [x] Test cleanup completes even after crash
- [x] Test unmount timeout forces termination
- [x] Test registry entry removed on unmount

#### Registry Tests
- [x] Test component registered on mount
- [x] Test component unregistered on unmount
- [x] Test lookup by id returns correct pid
- [x] Test list_all returns all mounted components

#### Hook Tests
- [x] Test after_mount hook fires after mount
- [x] Test before_unmount hook fires before cleanup
- [x] Test on_prop_change hook fires on prop change
- [x] Test multiple hooks execute in order

## Success Criteria

1. **ComponentServer** manages lifecycle for any component behaviour
2. **Init** validates props and creates initial state with timeout
3. **Mount** triggers after component enters tree, executes commands
4. **Update** detects prop changes and calls update callback
5. **Unmount** cleans up with timeout guarantee
6. **Registry** enables fast component lookup by id
7. **Hooks** fire at correct lifecycle points
8. All unit tests pass
9. Documentation complete with examples

## Current Status

**Status**: Complete

### Summary
- All tasks completed
- 53 new tests added
- Total project tests: 996
- All tests passing

### How to Run
```bash
mix test test/term_ui/component_server_test.exs
mix test test/term_ui/component_registry_test.exs
mix test test/term_ui/component/lifecycle_test.exs
```

## Notes

### Design Considerations

- **Lifecycle vs GenServer callbacks** - Lifecycle callbacks are component-specific (mount/unmount), GenServer callbacks (handle_info/handle_call) remain for general message handling
- **Commands pattern** - Mount/update return commands like handle_event for consistency
- **Registry scope** - Single global registry for now, partitioned registry for scaling later
- **Prop immutability** - Props are immutable once passed, updates create new prop maps

### Integration Points

- Uses behaviours from Section 3.1
- ComponentServer wraps components for event routing in Section 3.3
- Registry used for focus management in Section 3.4
- Supervisor strategy detailed in Section 3.6

### Future Considerations

- State persistence for crash recovery (Section 3.6)
- Hot code reloading support
- Distributed component trees
- Component pooling for performance
