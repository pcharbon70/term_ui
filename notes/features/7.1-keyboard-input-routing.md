# Feature Plan: Section 7.1 - Keyboard Input Routing

## Problem Statement

TermUI applications currently render to the terminal but cannot receive keyboard input. The Runtime's event dispatch system exists but has no input source - keyboard events don't flow from the terminal to components.

**Impact:** Without keyboard input routing:
- Users cannot interact with TUI applications
- The dashboard example displays but doesn't respond to q, t, arrow keys
- The Elm architecture loop is incomplete (no input → events → update cycle)

## Solution Overview

Implement a complete keyboard input pipeline:

```
stdin → InputReader → Parse → Event.Key → Runtime.send_event → dispatch → component
```

### Key Design Decisions

1. **Separate InputReader GenServer** - Dedicated process for non-blocking input reading
2. **Port-based stdin reading** - Use Erlang port for reliable raw input
3. **Escape sequence parser** - Handle CSI/SS3 sequences with timeout disambiguation
4. **Event.Key structs** - Use existing event types from Phase 5.1

### Architecture

```
┌─────────────┐     ┌──────────────┐     ┌─────────┐
│   stdin     │ ──> │ InputReader  │ ──> │ Runtime │
│  (port)     │     │  (GenServer) │     │         │
└─────────────┘     └──────────────┘     └─────────┘
                           │
                    ┌──────┴──────┐
                    │ EscapeParser │
                    │  (module)    │
                    └─────────────┘
```

## Technical Details

### File Structure

```
lib/term_ui/terminal/
├── input_reader.ex      # GenServer reading stdin
└── escape_parser.ex     # Parse escape sequences to events
```

### Dependencies

- `TermUI.Event.Key` - Event struct (already exists from 5.1)
- `TermUI.Runtime` - Event dispatch target
- Erlang `:erlang.open_port/2` - For stdin reading

### Escape Sequence Reference

Common sequences to parse:

| Key | Sequence | Notes |
|-----|----------|-------|
| Up | ESC [ A | CSI sequence |
| Down | ESC [ B | |
| Right | ESC [ C | |
| Left | ESC [ D | |
| Home | ESC [ H or ESC [ 1 ~ | Varies by terminal |
| End | ESC [ F or ESC [ 4 ~ | |
| F1 | ESC O P or ESC [ 11 ~ | SS3 or CSI |
| F2-F4 | ESC O Q/R/S | SS3 |
| F5-F12 | ESC [ 15-24 ~ | CSI with numbers |
| Ctrl+C | 0x03 | Control character |
| Ctrl+key | 0x01-0x1A | key - 0x60 |

## Implementation Plan

### Task 7.1.1: Terminal Input Reader ✅

- [x] 7.1.1.1 Create `TermUI.Terminal.InputReader` GenServer
- [x] 7.1.1.2 Implement port-based stdin reading with `{:spawn, "cat"}`
- [x] 7.1.1.3 Buffer partial escape sequences until complete or timeout (50ms)
- [x] 7.1.1.4 Handle UTF-8 multi-byte sequences
- [x] 7.1.1.5 Provide start_link/1 with target pid option

### Task 7.1.2: Escape Sequence Parsing ✅

- [x] 7.1.2.1 Create `TermUI.Terminal.EscapeParser` module
- [x] 7.1.2.2 Parse arrow keys (ESC [ A/B/C/D)
- [x] 7.1.2.3 Parse function keys F1-F12
- [x] 7.1.2.4 Parse Ctrl+key modifiers (0x01-0x1A)
- [x] 7.1.2.5 Parse Alt+key (ESC followed by key)
- [x] 7.1.2.6 Handle ambiguous ESC with timeout

### Task 7.1.3: Runtime Event Connection ✅

- [x] 7.1.3.1 Add input_reader field to Runtime.State
- [x] 7.1.3.2 Start InputReader in Runtime.init with self() as target
- [x] 7.1.3.3 Add handle_info for {:input, event} messages
- [x] 7.1.3.4 Route events through existing dispatch_event
- [x] 7.1.3.5 Stop InputReader in Runtime.terminate

### Unit Tests ✅

- [x] Test InputReader starts and stops cleanly
- [x] Test single character parsing
- [x] Test arrow key escape sequences
- [x] Test Ctrl+key detection
- [x] Test Alt+key detection
- [x] Test timeout disambiguation for lone ESC
- [x] Test keyboard event flows to component update

## Success Criteria

1. InputReader starts with Runtime and reads from stdin
2. Arrow keys parsed as Event.Key with :up/:down/:left/:right
3. Ctrl+C produces Event.Key with key: "c", ctrl: true
4. Alt+x produces Event.Key with key: "x", alt: true
5. Dashboard responds to q (quit), t (theme), arrows (navigate)
6. All existing tests continue to pass
7. New unit tests pass

## Current Status

- **Planning**: Complete
- **Implementation**: Complete
- **Tests**: Complete (59 tests passing)

## Notes/Considerations

- Port-based reading is more reliable than :io.get_chars in raw mode
- Escape sequence timeout (50ms) balances responsiveness vs disambiguation
- Some terminals send different sequences - start with common ones
- Alt+key sends ESC then key, which conflicts with raw ESC - use timeout
