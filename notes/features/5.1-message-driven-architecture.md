# Feature Plan: Section 5.1 - Message-Driven Architecture

## Problem Statement

TermUI needs a formal event system implementing The Elm Architecture for OTP. Currently, Phase 3 established basic event routing, but we need:
- Typed events representing all terminal input
- Component-specific message types with semantic meaning
- Pure update functions that transform state from messages
- Pure view functions that render state to UI
- Message batching to prevent redundant renders

This architecture creates predictable, debuggable state flow where every state change traces back to the message that caused it.

## Solution Overview

Implement five core components:

1. **Event Types** - Typed structs for all terminal input (Key, Mouse, Resize, Focus, Paste, Tick)
2. **Message Types** - Component-specific types and conventions for domain messages
3. **Update Function** - Pure callback signature `update(msg, state) :: {new_state, [command]}`
4. **View Function** - Pure callback signature `view(state) :: render_tree()`
5. **Message Batching** - Queue and batch process messages before single render

### Key Design Decisions

- **Separation of events and messages**: Events are external input; messages are domain-specific meanings
- **Pure functions**: Update and view must be side-effect free for testability
- **Commands for side effects**: Update returns commands, not results (implemented in 5.3)
- **Batching for performance**: Multiple messages apply before one render

## Technical Details

### File Structure

```
lib/term_ui/
├── event.ex              # Event type definitions
├── event/
│   ├── key.ex           # Key event struct
│   ├── mouse.ex         # Mouse event struct
│   ├── resize.ex        # Resize event struct
│   ├── focus.ex         # Focus event struct
│   ├── paste.ex         # Paste event struct
│   └── tick.ex          # Tick event struct
├── message.ex           # Message type conventions and helpers
├── component/
│   └── behaviour.ex     # Updated with update/view callbacks
└── message_queue.ex     # Message batching implementation
```

### Dependencies

- Phase 1 terminal input parsing (for event data)
- Phase 3 component system (for behaviour callbacks)

## Implementation Plan

### Task 5.1.1: Event Types ✅

Define typed event structs for all terminal input.

- [x] 5.1.1.1 Define `%TermUI.Event.Key{key: atom | char, modifiers: [atom]}`
- [x] 5.1.1.2 Define `%TermUI.Event.Mouse{action: atom, button: atom, x: integer, y: integer, modifiers: [atom]}`
- [x] 5.1.1.3 Define `%TermUI.Event.Resize{width: integer, height: integer}`
- [x] 5.1.1.4 Define `%TermUI.Event.Focus{type: :gained | :lost}`
- [x] 5.1.1.5 Define `%TermUI.Event.Paste{content: String.t()}`
- [x] 5.1.1.6 Define `%TermUI.Event.Tick{interval: integer}`

### Task 5.1.2: Message Types ✅

Define message type conventions for components.

- [x] 5.1.2.1 Define message type specification for component behaviours
- [x] 5.1.2.2 Implement message struct convention: `%MyComponent.Msg.SelectItem{index: 3}`
- [x] 5.1.2.3 Implement atom message support for simple messages: `:increment`, `:decrement`
- [x] 5.1.2.4 Implement message routing from events to messages via `event_to_msg/2` callback

### Task 5.1.3: Update Function ✅

Implement the core update function callback.

- [x] 5.1.3.1 Define `update(msg, state) :: {new_state, [command]}` callback signature
- [x] 5.1.3.2 Implement state-only return shorthand: `{new_state, []}`
- [x] 5.1.3.3 Implement unchanged state return: `:noreply` keeps state unchanged
- [x] 5.1.3.4 Implement update validation ensuring pure function (no side effects)

### Task 5.1.4: View Function ✅

Implement the view function callback.

- [x] 5.1.4.1 Define `view(state) :: render_tree()` callback signature
- [x] 5.1.4.2 Implement render tree types: nodes, text, styled spans
- [x] 5.1.4.3 Implement view memoization caching result when state unchanged
- [x] 5.1.4.4 Implement view performance warning for slow view functions

### Task 5.1.5: Message Batching ✅

Implement message queue and batch processing.

- [x] 5.1.5.1 Implement message queue for incoming messages
- [x] 5.1.5.2 Implement batch processing applying all queued messages sequentially
- [x] 5.1.5.3 Implement single render after batch processing
- [x] 5.1.5.4 Implement batch size limits to prevent unbounded accumulation

### Unit Tests ✅

- [x] Test event types contain correct fields
- [x] Test message routing delivers to correct component
- [x] Test update function produces new state from message
- [x] Test update commands are collected for execution
- [x] Test view function produces render tree from state
- [x] Test view memoization skips render for unchanged state
- [x] Test message batching applies all messages before render

## Success Criteria

1. All event types properly defined with correct fields
2. Message type conventions documented and enforced
3. Update function callback works with state and commands
4. View function callback produces render trees
5. Message batching reduces redundant renders
6. All unit tests pass

## Current Status

- **Planning**: Complete
- **Implementation**: Complete
- **Tests**: 130 tests passing
