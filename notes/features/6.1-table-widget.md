# Feature Plan: Section 6.1 - Table Widget

## Problem Statement

TermUI needs a table widget for displaying tabular data - one of the most commonly needed widgets for data-driven applications. Tables must handle large datasets efficiently through virtual scrolling, support user interaction (selection, sorting, editing), and provide flexible column configuration with fixed and proportional widths.

## Solution Overview

Implement a comprehensive Table widget with five subsystems:

1. **Table Structure** - Column specs, data binding, configuration props
2. **Column Layout** - Width calculation using constraint solver
3. **Virtual Scrolling** - Render only visible rows for performance
4. **Selection and Navigation** - Single/multi selection, keyboard navigation
5. **Sorting** - Click-to-sort headers with direction indicators

### Key Design Decisions

- **StatefulComponent-based** - Table maintains scroll position, selection, and sort state
- **Virtual scrolling** - Only render visible rows for 10,000+ row performance
- **Constraint-based columns** - Use existing constraint solver for width distribution
- **Callback-driven** - Parent notified via callbacks for selection and sorting changes
- **Composable rendering** - Use existing RenderNode helpers for table structure

## Technical Details

### File Structure

```
lib/term_ui/widgets/
├── table.ex              # Main Table widget
└── table/
    ├── column.ex         # Column specification struct
    └── state.ex          # Table state management
```

### Dependencies

- `TermUI.StatefulComponent` - Behaviour for stateful widget
- `TermUI.Layout.Constraint` - Column width calculations
- `TermUI.Component.Helpers` - Render tree builders
- `TermUI.Event` - Keyboard and mouse events

## Implementation Plan

### Task 6.1.1: Table Structure

- [x] 6.1.1.1 Define column spec: `%Column{header: String.t(), key: atom, width: constraint, render: fun}`
- [x] 6.1.1.2 Implement data binding accepting list of row maps
- [x] 6.1.1.3 Implement configuration props: `:single_select`, `:multi_select`, `:sortable`
- [x] 6.1.1.4 Implement style props for header, rows, selected rows, alternating backgrounds

### Task 6.1.2: Column Layout

- [x] 6.1.2.1 Implement column width calculation using constraint solver
- [x] 6.1.2.2 Support fixed width: `Constraint.length(20)`
- [x] 6.1.2.3 Support proportional width: `Constraint.ratio(2)`
- [x] 6.1.2.4 Implement column resize handles (drag to adjust width)

### Task 6.1.3: Virtual Scrolling

- [x] 6.1.3.1 Implement scroll state tracking scroll offset
- [x] 6.1.3.2 Implement visible range calculation from offset and height
- [x] 6.1.3.3 Implement row recycling rendering only visible rows
- [x] 6.1.3.4 Implement smooth scrolling with keyboard and mouse wheel

### Task 6.1.4: Selection and Navigation

- [x] 6.1.4.1 Implement single selection with arrow keys and click
- [x] 6.1.4.2 Implement multi-selection with Ctrl+click and Shift+click
- [x] 6.1.4.3 Implement keyboard navigation: arrows, PageUp/Down, Home/End
- [x] 6.1.4.4 Implement `on_select` callback for selection changes

### Task 6.1.5: Sorting

- [x] 6.1.5.1 Implement sort state tracking sort column and direction
- [x] 6.1.5.2 Implement header click handling toggling sort
- [x] 6.1.5.3 Implement row sorting by column values
- [x] 6.1.5.4 Implement sort indicator in header

### Unit Tests

- [x] Test table renders correct columns and headers
- [x] Test column width calculation distributes space correctly
- [x] Test virtual scrolling renders only visible rows
- [x] Test selection state updates on row click
- [x] Test keyboard navigation moves between rows
- [x] Test sorting reorders rows by column

## Success Criteria

1. Table renders columns and headers correctly
2. Column widths calculated using constraint solver
3. Virtual scrolling handles 10,000+ rows at 60 FPS
4. Selection works with keyboard and mouse
5. Sorting toggles on header click with indicators
6. All unit tests pass

## Current Status

- **Planning**: Complete
- **Implementation**: Complete
- **Tests**: Complete
