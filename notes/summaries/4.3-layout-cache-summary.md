# Summary: Section 4.3 Layout Cache

## Overview

Implemented an ETS-based layout cache with LRU eviction for caching constraint solver results. The cache provides O(1) lookup for unchanged layouts, dramatically improving rendering performance.

## Changes Made

### New Files

- `lib/term_ui/layout/cache.ex` - Layout cache GenServer with ETS storage
- `test/term_ui/layout/cache_test.exs` - Comprehensive unit tests (23 tests)

### Implementation Details

#### Core Features

| Feature | Description |
|---------|-------------|
| ETS storage | Fast concurrent reads without process bottleneck |
| Constraint hashing | Efficient key comparison using `:erlang.phash2` |
| LRU eviction | Bounded memory with configurable limits |
| Statistics | Track hits, misses, and hit rate |

#### Main Functions

| Function | Purpose |
|----------|---------|
| `solve/3` | Cached solve - checks cache, falls back to solver |
| `solve_uncached/3` | Direct solver access without caching |
| `lookup/1` | Manual cache lookup |
| `insert/2` | Manual cache insert |
| `invalidate/1` | Remove specific entry |
| `invalidate_constraints/1` | Remove all entries for constraint set |
| `clear/0` | Remove all entries (on resize) |
| `stats/0` | Get cache statistics |
| `warm/1` | Pre-populate cache |

#### Cache Structure

```elixir
# Key: {constraints_hash, width, height}
# Value: {result, access_time}

# Example
key = {:erlang.phash2(constraints), 100, 50}
{[%{x: 0, y: 0, width: 100, height: 50}], 12345678}
```

#### Configuration

- `:max_size` - Maximum entries (default 500)
- `:eviction_count` - Entries to remove per eviction (default 50)

## Test Coverage

23 unit tests covering:
- Basic caching (hit/miss tracking)
- Lookup and insert operations
- Cache invalidation (specific and by constraints)
- Clear all entries
- LRU eviction behavior
- Statistics accuracy
- Cache warming
- Solver option support (gap, direction)

All tests pass.

## Design Decisions

1. **GenServer + ETS** - GenServer for lifecycle, ETS for concurrent reads
2. **Async eviction** - Non-blocking insert with async eviction
3. **Hash-based keys** - Fast lookup without deep constraint comparison
4. **Access time tracking** - Updated on each lookup for accurate LRU
5. **Configurable limits** - Tune for memory/hit-rate tradeoff

## Integration Points

This module will be used by:
- Container components for layout caching
- Application supervision tree (start cache)
- Resize handlers (clear cache)

## Usage Examples

```elixir
alias TermUI.Layout.Cache

# Add to supervision tree
children = [
  {Cache, max_size: 1000}
]

# Cached solve
constraints = [Constraint.length(30), Constraint.fill()]
area = %{x: 0, y: 0, width: 100, height: 10}
rects = Cache.solve(constraints, area)

# Get statistics
stats = Cache.stats()
# => %{size: 150, hits: 1234, misses: 56, hit_rate: 0.957}

# Clear on terminal resize
Cache.clear()

# Pre-warm for predictable performance
Cache.warm([
  {sidebar_constraints, area, []},
  {main_constraints, area, []}
])
```

## Files Modified

- `notes/features/4.3-layout-cache.md` - marked all tasks complete

## How to Test

```bash
mix test test/term_ui/layout/cache_test.exs
```

## Next Steps

- Section 4.4: Flexbox-Inspired Alignment - position within allocated space
- Integrate cache into application supervision tree
