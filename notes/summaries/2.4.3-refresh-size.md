# Summary: Task 2.4.3 - Implement refresh_size/1 Callback

**Branch:** `feature/2.4.3-refresh-size`
**Date:** 2025-12-05
**Status:** Complete

## Overview

Implemented the `refresh_size/1` callback for the Raw backend to re-query terminal dimensions. This is used to handle terminal resize events (SIGWINCH) by updating the cached size in state.

## Implementation

### refresh_size/1

Re-queries terminal dimensions and updates state:
- Queries `:io.rows/0` and `:io.columns/0`
- Falls back to LINES/COLUMNS environment variables
- Returns 3-tuple: `{:ok, new_size, updated_state}` on success
- Returns `{:error, :size_detection_failed}` on failure

### Code Changes

```elixir
@doc """
Re-queries terminal dimensions and updates state.

This function queries the terminal for its current size using `:io.rows/0`
and `:io.columns/0`, then updates the cached size in state. It should be
called after receiving a SIGWINCH signal to handle terminal resize events.

## Return Value

- `{:ok, {rows, cols}, updated_state}` - New dimensions and updated state
- `{:error, :size_detection_failed}` - Failed to query terminal dimensions

## SIGWINCH Handling

Terminal resize events are delivered via SIGWINCH. Your application should:

1. Register a signal handler for SIGWINCH
2. Call `refresh_size/1` when the signal is received
3. Trigger a re-render with the new dimensions
...
"""
@spec refresh_size(t()) :: {:ok, TermUI.Backend.size(), t()} | {:error, :size_detection_failed}
def refresh_size(state) do
  case get_terminal_size(nil) do
    {:ok, new_size} ->
      {:ok, new_size, %{state | size: new_size}}

    {:error, _reason} ->
      {:error, :size_detection_failed}
  end
end
```

## Tests Added

9 new tests in two describe blocks:

### `describe "refresh_size/1 callback"`

| Test | Description |
|------|-------------|
| exports refresh_size/1 function | Function export verification |
| returns 3-tuple on success | Return value format |
| updates state.size on success | State mutation verification |
| preserves other state fields on success | Only size changes |
| returns error when size detection fails | Error handling |
| has documentation | Doc presence and SIGWINCH mention |
| documentation mentions error handling | Error doc coverage |

### `describe "refresh_size/1 with mocked environment"`

| Test | Description |
|------|-------------|
| uses environment variable fallback | LINES/COLUMNS fallback works |
| returns error with invalid environment variables | Invalid env handling |

## Files Modified

| File | Changes |
|------|---------|
| `lib/term_ui/backend/raw.ex` | Added refresh_size/1 (+50 lines) |
| `test/term_ui/backend/raw_test.exs` | Added 9 tests (+120 lines) |
| `notes/planning/multi-renderer/phase-02-raw-backend.md` | Marked Section 2.4 complete |

## Verification

- `mix compile` - Compiles without warnings
- `mix test test/term_ui/backend/raw_test.exs` - 102 tests pass (9 new)
- `mix format --check-formatted` - Code properly formatted

## Design Decisions

### Return Value Pattern

The 3-tuple `{:ok, new_size, updated_state}` was chosen over `{:ok, updated_state}` because:
1. Provides the new size directly for immediate use
2. Allows caller to detect size change without comparing old/new state
3. Mirrors patterns in other Elixir libraries (e.g., `Access.get_and_update/3`)

### Reusing get_terminal_size/1

The existing private `get_terminal_size/1` function handles all size detection logic including:
- `:io.rows/0` and `:io.columns/0` queries
- Environment variable fallback (LINES/COLUMNS)
- Error handling

By reusing this, `refresh_size/1` maintains consistency with `init/1` behavior.

### Test Environment Considerations

Tests account for varying environments:
- Real terminals where `:io.rows/0` succeeds
- Test environments where it returns `{:error, :enotsup}`
- Environment variable fallback verification

## Impact

- **Subtasks completed**: 2.4.3.1-4 (all 4 subtasks)
- **Section 2.4 progress**: Complete (all 3 tasks done)
- **Also completed**: 2.4.2.3-4 which reference refresh_size/1
- **No breaking changes**: New function added alongside existing API
