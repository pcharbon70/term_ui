# Summary: 2.5 Escape Sequence Batching

## Overview

Implemented `SequenceBuffer` module that batches escape sequences for efficient terminal output. The module accumulates escape sequences and text in an iolist, then flushes to output when threshold is reached or frame completes. This reduces system call overhead and ensures atomic frame updates.

## Implementation

### Files Created
- `lib/term_ui/renderer/sequence_buffer.ex` - Core sequence buffer module (~320 lines)
- `test/term_ui/renderer/sequence_buffer_test.exs` - Comprehensive test suite (34 tests)
- `notes/features/2.5-escape-sequence-batching.md` - Feature planning document

### Key Features

1. **Iolist Accumulator**
   - Efficient append via prepend + reverse on flush
   - No intermediate copying
   - Tracks size for threshold management

2. **SGR Sequence Combining**
   - `ESC[1mESC[31m` becomes `ESC[1;31m`
   - Reduces byte output
   - Pending SGR parameter accumulation

3. **Style Delta Tracking**
   - Emits only changed style parameters
   - Tracks `last_style` for comparison
   - Handles attribute removal with "off" codes

4. **Flush Management**
   - Size threshold auto-flush (default 4KB)
   - Frame completion flush
   - Explicit flush API
   - Statistics tracking (total bytes, flush count)

### API

```elixir
# Create buffer
buffer = SequenceBuffer.new()
buffer = SequenceBuffer.new(threshold: 1024)

# Append data
{:ok, buffer} = SequenceBuffer.append(buffer, "\\e[1;1H")
{:flush, data, buffer} = SequenceBuffer.append(buffer, "large data")
buffer = SequenceBuffer.append!(buffer, "text")  # Ignore flush result

# Style handling
buffer = SequenceBuffer.append_style(buffer, style)
buffer = SequenceBuffer.reset_style(buffer)

# SGR combining
buffer = SequenceBuffer.add_sgr_param(buffer, "1")
buffer = SequenceBuffer.add_sgr_param(buffer, "31")
buffer = SequenceBuffer.emit_pending_sgr(buffer)  # Emits ESC[1;31m

# Flush
{data, buffer} = SequenceBuffer.flush(buffer)

# Query
size = SequenceBuffer.size(buffer)
is_empty = SequenceBuffer.empty?(buffer)
{total_bytes, flush_count} = SequenceBuffer.stats(buffer)
iodata = SequenceBuffer.to_iodata(buffer)

# Reset
buffer = SequenceBuffer.clear(buffer)
```

### Color Support

- Named colors: `:black`, `:red`, `:green`, `:yellow`, `:blue`, `:magenta`, `:cyan`, `:white`, `:default`
- 256-color palette: integers 0-255 (`38;5;N` / `48;5;N`)
- True color RGB: tuples `{r, g, b}` (`38;2;R;G;B` / `48;2;R;G;B`)

### Attribute Support

- Bold (1/22), Dim (2/22), Italic (3/23), Underline (4/24)
- Blink (5/25), Reverse (7/27), Hidden (8/28), Strikethrough (9/29)

## Test Results

- 34 tests, 0 failures
- Total project tests: 626
- Credo strict mode: No issues

## Technical Notes

- Iolists avoid copying on append - prepend and reverse on flush
- SGR combining saves 4+ bytes per adjacent style sequence
- Default flush threshold (4KB) balances memory and syscall overhead
- Frame completion ensures atomic visual updates

## Next Steps

Section 2.6: Framerate Limiter
