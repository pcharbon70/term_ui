# Summary: Section 5.3 - Command System

## Implementation Overview

Implemented the command system for managing side effects in TermUI applications. Commands are declarative data structures that describe effects to perform, executed asynchronously by a Task.Supervisor-based executor.

## Key Components

### Command Struct (`lib/term_ui/command.ex`)

Defines the command data structure and builder functions:

```elixir
%Command{
  id: reference(),        # Unique ID for cancellation
  type: atom(),           # :timer, :interval, :file_read, :send_after, :none
  payload: term(),        # Type-specific data
  on_result: term(),      # Message to send on completion
  timeout: pos_integer()  # Optional execution timeout
}
```

Builder functions:
- `Command.timer(delay_ms, on_result)` - Deliver message after delay
- `Command.interval(interval_ms, on_result)` - Deliver repeated messages
- `Command.file_read(path, on_result)` - Read file contents
- `Command.send_after(component, message, delay)` - Send to specific component
- `Command.none()` - No-op command
- `Command.with_timeout(cmd, timeout_ms)` - Add timeout

### Command Executor (`lib/term_ui/command/executor.ex`)

GenServer that executes commands under Task.Supervisor:

- **Fault isolation** - Failed commands don't crash the runtime
- **Result delivery** - Sends `{:command_result, component_id, command_id, result}` to runtime
- **Concurrent execution** - Multiple commands run in parallel
- **Cancellation** - Cancel by ID or all for a component
- **Timeout support** - Commands can specify max execution time
- **Max concurrent limit** - Prevents resource exhaustion (default 100)

## Usage Pattern

```elixir
# In component update function
def update(:fetch_data, state) do
  cmd = Command.file_read("/path/to/data", :data_loaded)
  {%{state | loading: true}, [cmd]}
end

def update({:data_loaded, {:ok, content}}, state) do
  {%{state | loading: false, data: content}, []}
end

def update({:data_loaded, {:error, reason}}, state) do
  {%{state | loading: false, error: reason}, []}
end
```

## Command Types

| Type | Description | Result |
|------|-------------|--------|
| `:timer` | One-shot delay | `on_result` message |
| `:interval` | Repeated ticks | `on_result` message each tick |
| `:file_read` | Read file | `{on_result, {:ok, content} \| {:error, reason}}` |
| `:send_after` | Delayed message to component | `{:send_to, component, message}` |
| `:none` | No operation | No result |

## Executor API

```elixir
# Start executor
{:ok, executor} = Executor.start_link()

# Execute command
{:ok, cmd_id} = Executor.execute(executor, cmd, runtime_pid, component_id)

# Cancel specific command
:ok = Executor.cancel(executor, cmd_id)

# Cancel all for component (on unmount)
:ok = Executor.cancel_all_for_component(executor, component_id)

# Check running count
count = Executor.running_count(executor)
```

## Design Decisions

1. **Commands as data** - Structs not functions for inspectability and testability

2. **Task.Supervisor isolation** - Each command runs in its own task, failures are contained

3. **Result as message** - Commands return results through the message system, keeping update pure

4. **Concurrent by default** - Independent commands execute in parallel

5. **Explicit cancellation** - Commands can be cancelled by ID or on component unmount

## Test Coverage

36 tests covering:
- Command structure and validation
- Timer execution and delivery
- Interval repeated messages
- File read success and errors
- Send_after routing
- Command cancellation
- Cancel all for component
- Max concurrent limits
- Timeout handling
- Concurrent execution

## Integration Points

- **Runtime** (`TermUI.Runtime`) - Receives command results and routes to components
- **Components** - Return commands from update functions
- **Elm Architecture** - Completes the events → messages → commands → results cycle

## Future Work

- HTTP request commands
- Clipboard read/write commands
- Process spawning commands
- Command chaining for sequences
- Result aggregation for batch commands
