# Summary: Section 7.1 - Keyboard Input Routing

## What Was Implemented

This section implements complete keyboard input routing from stdin to components, enabling interactive TUI applications.

### New Modules

1. **`TermUI.Terminal.EscapeParser`** (`lib/term_ui/terminal/escape_parser.ex`)
   - Parses terminal escape sequences into Event.Key structs
   - Handles CSI sequences (ESC[...), SS3 sequences (ESCO...), and control characters
   - Returns parsed events and any remaining unparsed bytes for buffering
   - Key function: `parse/1` takes binary input, returns `{events, remaining}`
   - Helper: `partial_sequence?/1` for timeout disambiguation

2. **`TermUI.Terminal.InputReader`** (`lib/term_ui/terminal/input_reader.ex`)
   - GenServer that reads keyboard input from stdin via port
   - Uses `Port.open({:spawn, "cat"}, [:binary, :eof])` for non-blocking reads
   - Buffers partial escape sequences and uses 50ms timeout for disambiguation
   - Sends events as `{:input, %Event.Key{}}` to configured target process

### Modified Modules

1. **`TermUI.Runtime.State`** (`lib/term_ui/runtime/state.ex`)
   - Added `input_reader: pid() | nil` field to track InputReader process

2. **`TermUI.Runtime`** (`lib/term_ui/runtime.ex`)
   - Starts InputReader in `init/1` when terminal is available
   - Added `handle_info({:input, event}, state)` to receive keyboard events
   - Routes events through existing `dispatch_event/2` mechanism
   - Stops InputReader in `terminate/2` for clean shutdown

## Escape Sequences Supported

### Arrow Keys
- Up/Down/Right/Left: ESC[A/B/C/D

### Navigation Keys
- Home: ESC[H or ESC[1~
- End: ESC[F or ESC[4~
- Insert: ESC[2~
- Delete: ESC[3~
- PageUp: ESC[5~
- PageDown: ESC[6~

### Function Keys
- F1-F4: ESCOP/Q/R/S (SS3) or ESC[11-14~ (CSI)
- F5-F12: ESC[15-24~

### Modifiers
- Ctrl+key: byte values 0x01-0x1A (except 8/9/13 which map to special keys)
- Alt+key: ESC followed by key
- Modified arrows: ESC[1;modifierA/B/C/D (2=shift, 3=alt, 5=ctrl, etc.)

### Special Keys
- Backspace: 0x08 or 0x7F
- Tab: 0x09
- Enter: 0x0D
- Escape: Lone ESC (after 50ms timeout)

## Architecture

```
stdin → Port → InputReader → EscapeParser → Event.Key → Runtime → dispatch_event → component
```

The input pipeline:
1. Port reads raw bytes from stdin
2. InputReader buffers and sends to EscapeParser
3. EscapeParser converts to Event.Key structs with modifiers
4. InputReader sends events to Runtime via `{:input, event}`
5. Runtime dispatches to focused component
6. Component's `event_to_msg/2` converts to application message
7. Component's `update/2` handles the message

## Testing

### New Test Files
- `test/term_ui/terminal/escape_parser_test.exs` - 52 tests covering all sequence types
- `test/term_ui/terminal/input_reader_test.exs` - 7 tests for GenServer lifecycle

### Test Coverage
- Single character parsing (lowercase, uppercase, numbers, special)
- Control character parsing (Ctrl+A through Ctrl+Z)
- Arrow key parsing
- Navigation key parsing (Home, End, Insert, Delete, PageUp/Down)
- Function key parsing (F1-F12 in both CSI and SS3 forms)
- Alt+key modifier detection
- Modified arrow keys (Shift/Alt/Ctrl combinations)
- UTF-8 multi-byte characters (2, 3, and 4 byte sequences)
- Incomplete sequence buffering
- Partial sequence detection

## Usage

After this implementation, TUI applications can receive keyboard input:

```elixir
# In your component's event_to_msg/2
def event_to_msg(%Event.Key{key: "q"}, _state), do: {:msg, :quit}
def event_to_msg(%Event.Key{key: :up}, _state), do: {:msg, :move_up}
def event_to_msg(%Event.Key{key: "c", modifiers: modifiers}, _state) do
  if :ctrl in modifiers, do: {:msg, :interrupt}, else: :ignore
end
```

The dashboard example should now respond to:
- `q` - Quit
- `t` - Toggle theme
- Arrow keys - Navigate

## Technical Notes

1. **Port vs :io.get_chars**: Using a port with `cat` is more reliable for raw mode input than `:io.get_chars`, which can have issues with raw terminal mode.

2. **Escape Timeout**: The 50ms timeout balances responsiveness (user pressing ESC to cancel) with allowing time for escape sequence bytes to arrive. This matches what most TUI frameworks use.

3. **Modifiers as List**: Event.Key uses `modifiers: [:ctrl, :alt, :shift]` rather than boolean fields, allowing easy membership testing with `in`.

4. **Pattern Match Order**: The escape parser puts specific byte patterns (8=backspace, 9=tab, 13=enter) before the general Ctrl+key range (1..26) to ensure correct parsing.

## Files Changed

- Created: `lib/term_ui/terminal/escape_parser.ex`
- Created: `lib/term_ui/terminal/input_reader.ex`
- Created: `test/term_ui/terminal/escape_parser_test.exs`
- Created: `test/term_ui/terminal/input_reader_test.exs`
- Created: `notes/features/7.1-keyboard-input-routing.md`
- Modified: `lib/term_ui/runtime/state.ex` (added input_reader field)
- Modified: `lib/term_ui/runtime.ex` (integrated InputReader)
