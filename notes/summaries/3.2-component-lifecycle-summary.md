# Summary: Section 3.2 Component Lifecycle

## Overview

Implemented the component lifecycle management system that handles components from creation to destruction. This provides standardized lifecycle stages (init, mount, update, unmount) integrated with OTP patterns.

## Files Created

### Core Modules
- `lib/term_ui/component_server.ex` - GenServer managing component lifecycle
- `lib/term_ui/component_registry.ex` - ETS-based registry for component lookup
- `lib/term_ui/component_supervisor.ex` - DynamicSupervisor for component processes

### Modified Files
- `lib/term_ui/stateful_component.ex` - Added mount/update/unmount callbacks

### Test Files
- `test/term_ui/component_server_test.exs` - 33 tests
- `test/term_ui/component_registry_test.exs` - 14 tests
- `test/term_ui/component_supervisor_test.exs` - 6 tests

**Total: 53 new tests**

## Architecture

### Lifecycle State Machine

```
[not_started] -> init -> [initialized] -> mount -> [mounted] -> unmount -> [unmounted]
                                              ^                    |
                                              |---- update --------|
```

### ComponentServer

GenServer wrapper that manages lifecycle for any component:
- Handles init with timeout enforcement (default 5000ms)
- Manages mount transition and command execution
- Detects prop changes for selective updates
- Ensures cleanup on unmount and terminate

### ComponentRegistry

ETS-based registry for fast component lookup:
- Register/unregister on mount/unmount
- Lookup by id or pid
- Automatic cleanup via process monitoring
- Concurrent read access

### ComponentSupervisor

DynamicSupervisor for runtime component management:
- Start/stop components dynamically
- Transient restart strategy (restart on crash)
- Process isolation via one_for_one strategy

## Lifecycle Callbacks

Added to StatefulComponent behaviour:

```elixir
# Mount - component enters active tree
@callback mount(state) :: {:ok, state} | {:ok, state, commands} | {:stop, reason}

# Update - props changed
@callback update(new_props, state) :: {:ok, state} | {:ok, state, commands}

# Unmount - component removed from tree
@callback unmount(state) :: :ok
```

All callbacks are optional with default implementations.

## Hook System

Hooks for simple lifecycle side-effects:
- `:after_mount` - After successful mount
- `:before_unmount` - Before unmount cleanup
- `:on_prop_change` - When props change

```elixir
ComponentServer.register_hook(pid, :after_mount, fn state ->
  Logger.info("Component mounted with state: #{inspect(state)}")
end)
```

## API Examples

### Starting a Component

```elixir
# Via supervisor
{:ok, pid} = ComponentSupervisor.start_component(MyButton, %{label: "OK"}, id: :submit)

# Mount to activate
:ok = ComponentServer.mount(pid)

# Update props
:ok = ComponentServer.update_props(pid, %{label: "Cancel"})

# Send events
:ok = ComponentServer.send_event(pid, {:click, x, y})

# Unmount
:ok = ComponentServer.unmount(pid)
```

### Registry Lookup

```elixir
# Find by id
{:ok, pid} = ComponentRegistry.lookup(:submit)

# Find id by pid
{:ok, id} = ComponentRegistry.lookup_id(pid)

# List all
components = ComponentRegistry.list_all()
```

## Key Features

1. **Init timeout** - Prevents slow init from blocking startup
2. **Prop change detection** - Only calls update when props differ
3. **Command execution** - Mount/update can return side-effect commands
4. **Automatic cleanup** - Registry monitors processes for auto-unregister
5. **Lifecycle validation** - Operations require correct lifecycle state

## Test Results

- 53 new tests pass
- Total project tests: 996
- No regressions

## Integration Points

- Uses behaviours from Section 3.1
- Registry used for event routing in Section 3.3
- Registry used for focus management in Section 3.4
- Supervisor strategy extended in Section 3.6

## Command Types

Supported commands from lifecycle callbacks:

```elixir
{:send, pid, message}    # Send message to process
{:timer, ms, message}    # Schedule delayed message
```

## Future Considerations

- State persistence for crash recovery (Section 3.6)
- Component pooling for performance
- Distributed component trees
- Hot code reloading support
