# Summary: Section 6.3 - Overlay Widgets

## Overview

Implemented three overlay widgets for TermUI: Dialog, AlertDialog, and Toast. These widgets display content above the normal component tree using z-ordering and provide essential patterns for user feedback and modal interactions.

## Implemented Components

### 1. Dialog Widget (`lib/term_ui/widgets/dialog.ex`)

A modal overlay for user interaction including confirmations and forms.

**Features:**
- Centered display with configurable width
- Semi-transparent backdrop
- Title bar with border
- Content area
- Button bar with keyboard navigation
- Focus trapping (Tab cycles within dialog)
- Escape to close (configurable)
- on_close and on_confirm callbacks

**API:**
```elixir
Dialog.new(
  title: "Confirm",
  content: content_node,
  buttons: [%{id: :cancel, label: "Cancel"}, %{id: :ok, label: "OK"}],
  on_confirm: fn button_id -> ... end
)
Dialog.visible?(state)
Dialog.show(state) / Dialog.hide(state)
Dialog.focus_button(state, button_id)
```

### 2. Alert Dialog Widget (`lib/term_ui/widgets/alert_dialog.ex`)

Specialized dialog for standardized messages with predefined buttons.

**Alert Types:**
- `:info` - Information (ℹ icon, OK button)
- `:success` - Success (✓ icon, OK button)
- `:warning` - Warning (⚠ icon, OK button)
- `:error` - Error (✗ icon, OK button)
- `:confirm` - Confirmation (? icon, Yes/No buttons)
- `:ok_cancel` - OK/Cancel dialog

**Features:**
- Automatic icon based on type
- Predefined button configurations
- Shortcut keys (Y/N for confirm dialogs)
- Escape returns appropriate result (No/Cancel)
- Default focus on primary button

**API:**
```elixir
AlertDialog.new(
  type: :confirm,
  title: "Delete File",
  message: "Are you sure?",
  on_result: fn result -> ... end
)
AlertDialog.get_type(state)
AlertDialog.set_message(state, "New message")
```

### 3. Toast Widget (`lib/term_ui/widgets/toast.ex`)

Brief auto-dismissing notifications that don't block interaction.

**Toast Types:**
- `:info`, `:success`, `:warning`, `:error`

**Positions:**
- `:top_left`, `:top_center`, `:top_right`
- `:bottom_left`, `:bottom_center`, `:bottom_right`

**Features:**
- Configurable auto-dismiss duration
- Multiple position options
- Click/Escape to dismiss
- Type-specific icons
- Higher z-order than dialogs (150)

**API:**
```elixir
Toast.new(
  message: "File saved",
  type: :success,
  duration: 3000,
  position: :bottom_right
)
Toast.should_dismiss?(state)
Toast.elapsed_time(state)
```

### 4. Toast Manager (`lib/term_ui/widgets/toast.ex`)

Manages multiple toast notifications with stacking.

**Features:**
- Toast stacking
- Maximum toast limit
- Auto-removal of dismissed toasts
- Configurable default duration

**API:**
```elixir
manager = ToastManager.new(max_toasts: 5)
manager = ToastManager.add_toast(manager, "Message", :success)
manager = ToastManager.tick(manager)  # Clean up expired
ToastManager.clear_all(manager)
```

## Test Coverage

Total: 77 new tests across all three widgets

### Dialog Tests (27 tests)
- Props and initialization
- Keyboard navigation (Tab, arrows, Enter, Space, Escape)
- Button focus cycling
- Callbacks
- Visibility control
- Render output

### AlertDialog Tests (26 tests)
- All alert types and icons
- Button configurations
- Shortcut keys (Y/N)
- Escape handling per type
- Result callbacks

### Toast Tests (24 tests)
- Toast positioning
- Auto-dismiss timing
- Manager stacking
- Max toasts limit
- Tick cleanup

## Technical Notes

### Z-Order Hierarchy
- Normal content: z = 0
- Dialogs/Alerts: z = 100
- Toasts: z = 150

### Overlay Structure
All overlay widgets return a map with positioning info:
```elixir
%{
  type: :overlay,
  content: rendered_content,
  x: pos_x,
  y: pos_y,
  z: z_order
}
```

### Focus Trapping
Dialog uses Tab to cycle through buttons, preventing escape:
```elixir
def handle_event(%Event.Key{key: :tab, modifiers: modifiers}, state) do
  direction = if :shift in modifiers, do: -1, else: 1
  state = move_button_focus(state, direction)
  {:ok, state}
end
```

### Auto-dismiss
Toast tracks creation time and checks elapsed duration:
```elixir
def should_dismiss?(state) do
  if state.duration do
    elapsed = System.monotonic_time(:millisecond) - state.created_at
    elapsed >= state.duration
  else
    false
  end
end
```

## Files Changed

### New Files
- `lib/term_ui/widgets/dialog.ex` (340 lines)
- `lib/term_ui/widgets/alert_dialog.ex` (330 lines)
- `lib/term_ui/widgets/toast.ex` (360 lines) - includes ToastManager
- `test/term_ui/widgets/dialog_test.exs` (215 lines)
- `test/term_ui/widgets/alert_dialog_test.exs` (200 lines)
- `test/term_ui/widgets/toast_test.exs` (265 lines)

## Dependencies

All widgets use the existing infrastructure:
- `TermUI.StatefulComponent` - State management behaviour
- `TermUI.Event.Key` / `TermUI.Event.Mouse` - Event handling
- Render helpers (`text`, `styled`, `stack`, `empty`)

## Usage Examples

### Dialog
```elixir
Dialog.new(
  title: "Save Changes",
  content: text("Do you want to save your changes before closing?"),
  buttons: [
    %{id: :discard, label: "Discard"},
    %{id: :cancel, label: "Cancel"},
    %{id: :save, label: "Save", default: true}
  ],
  on_confirm: fn
    :save -> save_and_close()
    :discard -> close_without_saving()
    :cancel -> stay_open()
  end
)
```

### Alert Dialog
```elixir
AlertDialog.new(
  type: :error,
  title: "Connection Failed",
  message: "Unable to connect to server. Please check your network.",
  on_result: fn :ok -> retry_connection() end
)
```

### Toast with Manager
```elixir
# In application state
manager = ToastManager.new(position: :top_right, max_toasts: 3)

# Add notifications
manager = ToastManager.add_toast(manager, "Settings saved", :success)
manager = ToastManager.add_toast(manager, "New message received", :info)

# In render loop
manager = ToastManager.tick(manager)  # Auto-dismiss expired
ToastManager.render(manager, area)
```

## Status

- Implementation: Complete
- Tests: 77 tests passing
- Documentation: Complete (moduledocs and function docs)
