# Summary: Section 3.3 Event Routing

## Overview

Implemented the event routing system that handles distribution of input events (keyboard, mouse, focus) to components based on focus state and screen position.

## Files Created

### Core Modules
- `lib/term_ui/event.ex` - Event type definitions (Key, Mouse, Focus, Custom)
- `lib/term_ui/event_router.ex` - Central event router GenServer
- `lib/term_ui/spatial_index.ex` - Position-based component lookup
- `lib/term_ui/event/propagation.ex` - Event bubbling/capture utilities
- `lib/term_ui/event/transformation.ex` - Coordinate and metadata transforms

### Modified Files
- `lib/term_ui/component_registry.ex` - Added parent/child tracking for propagation

### Test Files
- `test/term_ui/event_test.exs` - 28 tests
- `test/term_ui/spatial_index_test.exs` - 19 tests
- `test/term_ui/event_router_test.exs` - 22 tests
- `test/term_ui/event/propagation_test.exs` - 22 tests
- `test/term_ui/event/transformation_test.exs` - 20 tests

**Total: 111 new tests**

## Architecture

### Event Flow

```
Terminal Input → EventRouter → Route by type → Target Component
                     ↓                              ↓
              Keyboard: Focus              Mouse: Spatial Index
                     ↓                              ↓
              Focused Component          Component at (x, y)
                     ↓                              ↓
              handle_event/2 ←──────────────────────┘
                     ↓
              Bubble if unhandled
```

### Event Types

Four event structs for different input types:

```elixir
# Keyboard input
%Event.Key{key: :enter, char: nil, modifiers: [:ctrl], timestamp: ...}

# Mouse input
%Event.Mouse{action: :click, button: :left, x: 10, y: 5, modifiers: [], timestamp: ...}

# Focus changes
%Event.Focus{action: :gained | :lost, timestamp: ...}

# Application-defined
%Event.Custom{name: :submit, payload: %{value: "text"}, timestamp: ...}
```

### EventRouter

Central coordinator for all event routing:
- Routes keyboard events to focused component
- Routes mouse events to component at position via SpatialIndex
- Manages focus state and sends focus gained/lost events
- Supports broadcast to all components
- Optional fallback handler for unrouted events

### SpatialIndex

ETS-based position lookup for mouse events:
- Register component bounds with `update/4`
- Find component at position with `find_at/2`
- Z-order support for overlapping components (highest wins)
- Returns all overlapping components with `find_all_at/2`

### Event Propagation

Component tree traversal for event bubbling/capture:
- Bubble phase: target → root (default)
- Capture phase: root → target
- Stop on `:handled` or `:stopped` result
- Parent chain tracking via ComponentRegistry

### Event Transformation

Coordinate and metadata utilities:
- `to_local/2` - Screen to component-local coordinates
- `to_screen/2` - Local to screen coordinates
- `with_metadata/2` - Add routing metadata
- `matches?/2` - Filter events by criteria

## API Examples

### Routing Events

```elixir
# Route keyboard to focused
EventRouter.route(Event.key(:enter))

# Route mouse to position
EventRouter.route(Event.mouse(:click, :left, 10, 5))

# Route directly to component
EventRouter.route_to(:my_button, event)

# Broadcast to all
EventRouter.broadcast({:resize, 80, 24})
```

### Focus Management

```elixir
# Set focus
EventRouter.set_focus(:my_input)

# Get current focus
{:ok, :my_input} = EventRouter.get_focus()

# Clear focus
EventRouter.clear_focus()
```

### Spatial Registration

```elixir
# Register component bounds
SpatialIndex.update(:button, pid, %{x: 10, y: 5, width: 20, height: 3})

# Register with z-index for layering
SpatialIndex.update(:modal, pid, bounds, z_index: 100)

# Find component at position
{:ok, {:button, pid}} = SpatialIndex.find_at(15, 6)
```

### Event Propagation

```elixir
# Set up parent chain
Propagation.set_parent(:button, :panel)
Propagation.set_parent(:panel, :root)

# Bubble event from button
Propagation.bubble(event, :button)

# Capture from root to button
Propagation.capture(event, :button)
```

### Event Transformation

```elixir
# Transform to local coordinates
local = Transformation.to_local(mouse_event, component_bounds)
# {x: 15, y: 10} with bounds {x: 10, y: 5} → {x: 5, y: 5}

# Filter events
clicks = Transformation.filter(events, type: :mouse, action: :click)

# Check modifiers
Transformation.matches?(event, key: :c, modifiers_all: [:ctrl])
```

## Key Features

1. **Focused routing** - Keyboard events to focused component
2. **Spatial routing** - Mouse events to component at position
3. **Z-order handling** - Top component receives overlapping mouse events
4. **Broadcast support** - System events to all components
5. **Event bubbling** - Unhandled events propagate to parent
6. **Capture phase** - Events travel root to target
7. **Coordinate transform** - Screen to component-local
8. **Event filtering** - Match events by type, key, modifiers
9. **Fallback handler** - Handle unrouted events

## Test Results

- 111 new tests pass
- Total project tests: 1107
- No regressions

## Integration Points

- Uses ComponentRegistry for component lookup (from Section 3.2)
- ComponentRegistry extended with parent/child tracking
- Ready for focus management in Section 3.4
- Event types compatible with Phase 1 terminal parsing

## Component Event Handling

Components receive events via GenServer call:

```elixir
def handle_call({:event, event}, _from, state) do
  case event do
    %Event.Key{key: :enter} ->
      # Handle enter key
      {:reply, :handled, state}

    %Event.Mouse{action: :click} ->
      # Handle click
      {:reply, :handled, state}

    _ ->
      {:reply, :unhandled, state}  # Bubble to parent
  end
end
```

## Future Considerations

- Event delegation within containers
- Event throttling/debouncing
- Touch/gesture event support
- Drag and drop protocol
- Accessibility event routing
