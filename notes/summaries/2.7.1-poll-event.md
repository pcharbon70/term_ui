# Summary: Task 2.7.1 - Implement poll_event/2 Callback

**Branch:** `feature/2.7.1-poll-event`
**Date:** 2025-12-05
**Status:** Complete

## Overview

Implemented the `poll_event/2` callback for the Raw backend, enabling keyboard and mouse input handling with timeout support.

## Implementation Highlights

### Architecture

The implementation uses a synchronous polling approach:
1. **Event Queue** - Returns previously parsed events first
2. **Buffer Parsing** - Parses input buffer using `EscapeParser`
3. **Task-based Timeout** - Uses `Task.async` + `Task.yield` for non-blocking reads
4. **Escape Disambiguation** - 50ms timeout to distinguish lone ESC from escape sequences

### State Extensions

Added two new fields to `TermUI.Backend.Raw`:
- `input_buffer :: binary()` - Buffers partial escape sequences
- `event_queue :: [event()]` - Queues parsed events for sequential return

### Key Design Decisions

1. **One event per call** - Returns single event per `poll_event/2` call, queuing extras
2. **Delegated parsing** - Reuses existing `EscapeParser` module
3. **Task-based timeout** - Avoids blocking on `IO.getn/2` with configurable timeout
4. **Escape timeout** - 50ms window to complete escape sequences before emitting lone ESC

## Files Modified

| File | Lines Added |
|------|-------------|
| `lib/term_ui/backend/raw.ex` | ~200 |
| `test/term_ui/backend/raw_test.exs` | ~160 |
| `notes/planning/multi-renderer/phase-02-raw-backend.md` | Updated |
| `notes/features/2.7.1-poll-event.md` | Created |

## Test Coverage

15 new tests covering:
- Timeout when no input available
- Buffer initialization
- Single character parsing
- Multiple character sequences
- Special keys (enter, tab, backspace)
- Control sequences (Ctrl+C)
- Arrow keys (up, down, left, right)
- Function keys (F1-F4)
- Documentation verification
- Escape key timeout disambiguation

## Verification

- `mix compile` - no warnings
- 143 tests pass (15 new)
- `mix format --check-formatted` - properly formatted

## API

```elixir
# Non-blocking poll
{:timeout, state} = Raw.poll_event(state, 0)

# Wait up to 100ms
case Raw.poll_event(state, 100) do
  {:ok, %Event.Key{key: :enter}, state} -> handle_enter(state)
  {:ok, %Event.Mouse{action: :click}, state} -> handle_click(state)
  {:timeout, state} -> handle_idle(state)
  {:error, reason, state} -> handle_error(reason, state)
end
```

## Next Steps

The next tasks in Section 2.7 are:
- **Task 2.7.2**: Implement Escape Sequence Handling (largely done via EscapeParser delegation)
- **Task 2.7.3**: Implement Event Construction (largely done via EscapeParser)

Both 2.7.2 and 2.7.3 are substantially implemented since `poll_event/2` delegates to the existing `EscapeParser` which handles both escape sequences and event construction.
