# Summary: Section 5.4 - Mouse Support

## Implementation Overview

Implemented complete mouse support for TermUI applications including mode activation, event routing, drag tracking, scroll handling, and hover detection.

## Key Components

### Mouse Module (`lib/term_ui/mouse.ex`)

Provides mouse mode activation and utilities:

```elixir
# Enable mouse tracking modes
Mouse.enable_mouse()         # Normal tracking + SGR Extended
Mouse.enable_mouse_button()  # Button motion tracking
Mouse.enable_mouse_motion()  # All motion tracking
Mouse.disable_mouse()        # Disable all tracking
```

Helper functions:
- `scroll_action?/1` - Check if action is scroll
- `click_action?/1` - Check if action is click
- `motion_action?/1` - Check if action is motion

### Mouse Tracker (`lib/term_ui/mouse/tracker.ex`)

Tracks drag and hover state:

```elixir
# Create tracker
tracker = Tracker.new(drag_threshold: 3)

# Process mouse events
{tracker, events} = Tracker.process(tracker, mouse_event)

# Events generated:
# {:drag_start, button, x, y}
# {:drag_move, button, x, y, dx, dy}
# {:drag_end, button, x, y}

# Update hover state
{tracker, events} = Tracker.update_hover(tracker, component_id)

# Events generated:
# {:hover_enter, component_id}
# {:hover_leave, component_id}
```

Features:
- Configurable drag threshold
- Delta calculation for drag moves
- Automatic drag start detection
- Hover enter/leave events

### Mouse Router (`lib/term_ui/mouse/router.ex`)

Routes events to components by position:

```elixir
# Hit test at position
{component_id, local_x, local_y} = Router.hit_test(components, x, y)

# Route event with coordinate transformation
{target_id, transformed_event} = Router.route(components, mouse_event)

# Get all components at position (for bubbling)
hits = Router.hit_test_all(components, x, y)
```

Utilities:
- `to_local/3` - Global to local coordinates
- `to_global/3` - Local to global coordinates
- `point_in_bounds?/3` - Point containment check
- `bounds_overlap?/2` - Bounds intersection check
- `clip_to_bounds/3` - Clamp to bounds

## Mouse Tracking Modes

| Mode | Code | Description |
|------|------|-------------|
| Normal | 1000 | Button press/release |
| Button | 1002 | Motion while button pressed |
| Any | 1003 | All motion events |
| SGR Extended | 1006 | Decimal coordinates, M/m suffix |

SGR Extended mode is automatically enabled with all tracking modes for accurate coordinates (no 223 limit) and press/release distinction.

## Design Decisions

1. **SGR Extended always on** - All enable functions include 1006 for modern coordinate handling

2. **Drag threshold** - Prevents accidental drags from small movements (default 3 pixels)

3. **Component-local coordinates** - Events transformed to component space for easier handling

4. **Z-order routing** - Overlapping components resolved by z_index

5. **Stateless router** - Router is pure functions, state in tracker

## Test Coverage

41 tests covering:
- Mouse mode activation sequences
- Drag state machine (press → move → release)
- Drag threshold detection
- Hover enter/leave events
- Hit testing with z-order
- Coordinate transformation
- Bounds checking and clipping

## Usage Example

```elixir
# Enable mouse at startup
IO.write(Mouse.enable_mouse_motion())

# In runtime, track mouse state
tracker = Tracker.new()

# Process incoming event
{tracker, drag_events} = Tracker.process(tracker, event)

# Route to component
{target, local_event} = Router.route(components, event)

# Update hover state
{tracker, hover_events} = Tracker.update_hover(tracker, target)

# Disable on cleanup
IO.write(Mouse.disable_mouse())
```

## Integration Points

- **Runtime** - Route mouse events using Router
- **Components** - Receive local coordinates
- **Terminal** - Enable/disable tracking modes

## Future Work

- Integrate with Phase 3 spatial index
- Double-click detection
- Mouse capture for drag operations
- Cursor shape feedback (where supported)
