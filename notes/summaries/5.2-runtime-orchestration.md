# Summary: Section 5.2 - Runtime Orchestration

## Implementation Overview

Implemented the central runtime orchestrator for TermUI applications using The Elm Architecture dispatch loop.

## Key Components

### Runtime GenServer (`lib/term_ui/runtime.ex`)

The main application orchestrator that implements:

1. **Event Dispatch** - Routes events to appropriate components
   - Keyboard events → focused component
   - Mouse events → root (spatial index pending)
   - Resize/Focus/Tick → broadcast to all components

2. **Update Cycle** - Processes messages through component update functions
   - Transforms events to messages via `event_to_msg/2`
   - Calls component `update/2` and collects commands
   - Updates component state and marks dirty flag

3. **Render Trigger** - Framerate-limited rendering
   - Timer-based render ticks (default 16ms ~60 FPS)
   - Only renders when dirty flag is set
   - Calls component `view/1` to generate render tree

4. **Shutdown Coordination** - Graceful exit
   - Clears pending commands
   - Terminates components
   - Prevents new events during shutdown

### Runtime State (`lib/term_ui/runtime/state.ex`)

Struct containing:
- `root_module` - Root component module
- `root_state` - Root component state
- `message_queue` - FIFO message queue
- `render_interval` - Milliseconds between renders
- `dirty` - Whether render is needed
- `focused_component` - Currently focused component ID
- `components` - Registry of component entries
- `pending_commands` - Commands awaiting completion
- `shutting_down` - Shutdown flag

## Public API

```elixir
# Start runtime with root component
{:ok, runtime} = Runtime.start_link(root: MyApp.Root, render_interval: 16)

# Send terminal event
Runtime.send_event(runtime, Event.key(:enter))

# Send message directly to component
Runtime.send_message(runtime, :root, :increment)

# Deliver command result
Runtime.command_result(runtime, :root, ref, {:ok, data})

# Force immediate render
Runtime.force_render(runtime)

# Get current state (debugging)
state = Runtime.get_state(runtime)

# Initiate shutdown
Runtime.shutdown(runtime)
```

## Design Decisions

1. **Single GenServer runtime** - Centralized coordination simplifies state management and message ordering

2. **Dirty flag rendering** - Only renders when state changes, avoiding unnecessary work

3. **Event dispatch by type** - Different events route differently:
   - Keyboard to focused component
   - Mouse to spatial position (to be integrated with Phase 3)
   - Global events broadcast

4. **Graceful shutdown** - Prevents new events/messages, clears pending commands, terminates components

## Test Coverage

31 tests covering:
- Runtime initialization with various options
- Event dispatch to correct components
- Message processing and state updates
- Dirty flag management
- Render timing and force render
- Command collection and results
- Shutdown coordination
- Full Elm cycle integration

## Integration Points

- **Events** (`TermUI.Event`) - Terminal event types
- **Elm Behaviour** (`TermUI.Elm`) - Component callbacks
- **MessageQueue** (`TermUI.MessageQueue`) - FIFO message batching

## Future Work

- Integrate with Phase 3 spatial index for mouse event routing
- Implement actual command execution in 5.3
- Connect render trigger to Phase 2 buffer system
- Add parent-child component message passing
- Terminal restoration on shutdown
