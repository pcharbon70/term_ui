# Summary: Section 5.5 - Keyboard Shortcuts

## Implementation Overview

Implemented a keyboard shortcut system for TermUI applications with registry, matching, scopes, actions, and discoverability.

## Key Components

### Shortcut Struct

```elixir
%Shortcut{
  key: :s,                    # Key to match (or :any)
  modifiers: [:ctrl],         # Required modifiers
  action: {:message, :editor, :save},  # Action to execute
  scope: :global,             # When shortcut is active
  priority: 0,                # For conflict resolution
  description: "Save file",   # Help text
  sequence: nil               # For multi-key sequences like [:g, :g]
}
```

### Action Types

- `{:function, fun}` - Execute function, return result
- `{:message, component_id, message}` - Send message to component
- `{:command, command}` - Execute a command

### Scope Types

- `:global` - Always active
- `{:mode, mode_atom}` - Active when context mode matches
- `{:component, component_id}` - Active when component focused

## API

```elixir
# Start registry
{:ok, registry} = Shortcut.start_link()

# Register shortcut
Shortcut.register(registry, %Shortcut{
  key: :q,
  modifiers: [:ctrl],
  action: {:function, fn -> :quit end},
  scope: :global,
  description: "Quit application"
})

# Match key event
context = %{mode: :normal, focused_component: :editor}
case Shortcut.match(registry, key_event, context) do
  {:ok, shortcut} -> Shortcut.execute(shortcut)
  :no_match -> :ignore
end

# List shortcuts
all = Shortcut.list(registry)
global = Shortcut.list_for_scope(registry, :global)

# Format for display
Shortcut.format(shortcut)  # => "Ctrl+S"

# Unregister
Shortcut.unregister(registry, :q, [:ctrl])
```

## Features

### Modifier Matching

Requires exact modifier match:
```elixir
# Shortcut requires Ctrl+Shift
shortcut = %Shortcut{key: :s, modifiers: [:ctrl, :shift], ...}

# Ctrl alone won't match
Event.key(:s, modifiers: [:ctrl])  # no_match

# Ctrl+Shift matches
Event.key(:s, modifiers: [:ctrl, :shift])  # matches
```

### Key Sequences

Support vim-style multi-key sequences:
```elixir
shortcut = %Shortcut{
  key: :g,
  modifiers: [],
  action: {:function, fn -> :go_top end},
  sequence: [:g, :g]
}

# First 'g' - no match, starts sequence
# Second 'g' - sequence complete, matches
```

Sequences have a 1-second timeout.

### Priority Resolution

Higher priority wins on conflict:
```elixir
Shortcut.register(registry, %Shortcut{key: :s, modifiers: [:ctrl], priority: 0, ...})
Shortcut.register(registry, %Shortcut{key: :s, modifiers: [:ctrl], priority: 10, ...})

# Priority 10 shortcut will match
```

### Wildcard Matching

Match any key with `:any`:
```elixir
shortcut = %Shortcut{
  key: :any,
  modifiers: [:ctrl],
  action: {:function, fn -> :handle_ctrl_key end}
}
# Matches Ctrl+A, Ctrl+B, Ctrl+X, etc.
```

### Formatting

Consistent, readable format:
```elixir
Shortcut.format(%Shortcut{key: :s, modifiers: [:ctrl]})
# => "Ctrl+S"

Shortcut.format(%Shortcut{key: :s, modifiers: [:shift, :ctrl, :alt]})
# => "Ctrl+Alt+Shift+S"  (consistent ordering)
```

## Design Decisions

1. **GenServer registry** - Manages shortcuts and sequence state
2. **Priority-based conflicts** - Explicit resolution for overlapping shortcuts
3. **Scope hierarchy** - Global → mode → component scoping
4. **1-second sequence timeout** - Prevents stuck partial sequences
5. **Exact modifier matching** - No partial matches

## Test Coverage

27 tests covering:
- Shortcut registration and unregistration
- Key and modifier matching
- Scope filtering (global, mode, component)
- Sequence matching and timeout
- Action execution (function, message, command)
- Priority-based conflict resolution
- Wildcard matching
- Formatting for display
- Full workflow integration

## Usage Example

```elixir
# In application init
{:ok, shortcuts} = Shortcut.start_link(name: :shortcuts)

# Register standard shortcuts
Shortcut.register(shortcuts, %Shortcut{
  key: :q, modifiers: [:ctrl],
  action: {:message, :root, :quit},
  description: "Quit"
})

Shortcut.register(shortcuts, %Shortcut{
  key: :s, modifiers: [:ctrl],
  action: {:command, {:save, current_file()}},
  description: "Save"
})

# Vim-style go to top
Shortcut.register(shortcuts, %Shortcut{
  key: :g, modifiers: [],
  action: {:message, :editor, :go_top},
  sequence: [:g, :g],
  scope: {:mode, :normal},
  description: "Go to top"
})

# In event handler
def handle_key_event(event, context) do
  case Shortcut.match(:shortcuts, event, context) do
    {:ok, shortcut} ->
      case Shortcut.execute(shortcut) do
        {:send_message, id, msg} -> send_to_component(id, msg)
        {:execute_command, cmd} -> execute_command(cmd)
        result -> result
      end
    :no_match ->
      # Handle normally
  end
end
```

## Integration Points

- **Runtime** - Check shortcuts before component event_to_msg
- **Components** - Receive shortcut-triggered messages
- **Commands** - Execute shortcut-triggered commands
- **Help system** - Display available shortcuts
