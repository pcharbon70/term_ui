# Summary: Section 3.4 Focus Management

## Overview

Implemented the focus management system that tracks which component receives keyboard input, provides Tab/Shift+Tab navigation, and manages focus trapping for modal contexts.

## Files Created

### Core Modules
- `lib/term_ui/focus_manager.ex` - Central focus management GenServer
- `lib/term_ui/focus/traversal.ex` - Tab order calculation utilities
- `lib/term_ui/focus/indicator.ex` - Focus indicator styles

### Test Files
- `test/term_ui/focus_manager_test.exs` - 41 tests
- `test/term_ui/focus/traversal_test.exs` - 17 tests
- `test/term_ui/focus/indicator_test.exs` - 11 tests

**Total: 69 new tests**

## Architecture

### Focus Flow

```
Tab Key → FocusManager → Calculate Tab Order → Get Next Focusable
                ↓                                      ↓
         Update Focus State ←──────────────────────────┘
                ↓
         Send Focus Events (via EventRouter)
```

### FocusManager

Central coordinator for all focus operations:
- Tracks currently focused component
- Maintains focus stack for modal contexts
- Manages focus groups for trapping
- Integrates with EventRouter for event routing

### Focus Traversal

Tab order calculation utilities:
- Position-based ordering (y, x)
- Explicit tab_index support
- Filtering for focusable/disabled
- Wrap-around navigation

### Focus Indicators

Visual feedback styling:
- Default cyan border style
- Predefined themes (default, subtle, bold, minimal)
- Conversion to render Style structs

## API Examples

### Focus Management

```elixir
# Get current focus
{:ok, :my_input} = FocusManager.get_focused()

# Set focus
:ok = FocusManager.set_focused(:my_input)

# Clear focus
:ok = FocusManager.clear_focus()

# Check if focused
FocusManager.is_focused?(:my_input)
```

### Tab Navigation

```elixir
# Move to next focusable
:ok = FocusManager.focus_next()

# Move to previous focusable
:ok = FocusManager.focus_prev()
```

### Focus Stack (for modals)

```elixir
# Push current focus and set new
:ok = FocusManager.push_focus(:modal_button)

# Restore previous focus
:ok = FocusManager.pop_focus()
```

### Focus Trapping

```elixir
# Register a focus group
:ok = FocusManager.register_group(:modal, [:btn1, :btn2, :btn3])

# Trap focus within group
:ok = FocusManager.trap_focus(:modal)

# Release trap
:ok = FocusManager.release_focus()
```

### Tab Order Calculation

```elixir
# Calculate order from positions
order = Traversal.calculate_order(component_ids)

# With explicit tab indices
order = Traversal.calculate_order(ids, tab_indices: %{a: 1, b: 2})

# Get next/prev in order
next_id = Traversal.next(order, current_id)
prev_id = Traversal.prev(order, current_id)

# Filter to focusable only
focusable = Traversal.filter_focusable(ids, disabled: %{btn: true})
```

### Focus Indicators

```elixir
# Get default style
style = Indicator.default_style()
# %{fg: :cyan, bg: nil, bold: true, border: :single}

# Get predefined theme
style = Indicator.get_theme(:bold)

# Convert to render Style
render_style = Indicator.to_render_style(style)
```

## Key Features

1. **Focus tracking** - Single focused component at a time
2. **Tab navigation** - Next/prev with position-based ordering
3. **Tab index support** - Explicit ordering via tab_index
4. **Focus stack** - Push/pop for modal focus management
5. **Focus groups** - Named component groups
6. **Focus trapping** - Restrict navigation to group
7. **Auto-focus** - Request focus on component mount
8. **Focus indicators** - Customizable visual styles
9. **EventRouter integration** - Automatic focus event routing

## Focus State Structure

```elixir
%{
  current: :component_id | nil,
  stack: [:prev_focus_1, :prev_focus_2],
  groups: %{modal: [:btn1, :btn2]},
  trapped_group: :modal | nil
}
```

## Tab Order Algorithm

1. Get all registered components
2. Filter to focusable only (skip disabled, unfocusable)
3. Sort by tab_index (nil = last)
4. Within same tab_index, sort by position (y, x)
5. Navigate with wrap-around

## Test Results

- 69 new tests pass
- Total project tests: 1176
- No regressions

## Integration Points

- Uses EventRouter for focus event dispatch (from Section 3.3)
- Uses ComponentRegistry for component lookup (from Section 3.2)
- Uses SpatialIndex for position-based ordering (from Section 3.3)
- Components receive focus/blur events via handle_event

## Focus Events

Components receive focus events from EventRouter:

```elixir
def handle_call({:event, %Event.Focus{action: :gained}}, _from, state) do
  # Component gained focus
  {:reply, :handled, %{state | focused: true}}
end

def handle_call({:event, %Event.Focus{action: :lost}}, _from, state) do
  # Component lost focus
  {:reply, :handled, %{state | focused: false}}
end
```

## Future Considerations

- Directional focus navigation (arrow keys)
- Focus restoration on component remount
- Focus analytics for UX optimization
- Accessibility focus announcements
- Focus ring animation support
