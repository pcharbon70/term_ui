# Summary: Section 4.1 Constraint Types

## Overview

Implemented constraint types for the layout system, providing a declarative vocabulary for components to express space requirements. This is the foundation for the Phase 4 layout engine.

## Changes Made

### New Files

- `lib/term_ui/layout/constraint.ex` - Main constraint module with all types
- `test/term_ui/layout/constraint_test.exs` - Comprehensive unit tests (82 tests)

### Implementation Details

#### Constraint Type Structs

Six constraint types implemented as structs for pattern matching:

| Type | Purpose | Example |
|------|---------|---------|
| `Length` | Exact size in cells | `Constraint.length(20)` |
| `Percentage` | Fraction of parent | `Constraint.percentage(50)` |
| `Ratio` | Proportional share | `Constraint.ratio(2)` |
| `Min` | Minimum bound | `Constraint.min(10)` |
| `Max` | Maximum bound | `Constraint.max(100)` |
| `Fill` | Take remaining space | `Constraint.fill()` |

#### Constructor Functions

All constructors include validation:
- `length/1` - non-negative integer
- `percentage/1` - number 0-100
- `ratio/1` - positive number
- `min/1`, `max/1` - non-negative integer
- `min_max/2` - combined bounds (validates min â‰¤ max)
- `fill/0` - no arguments

#### Composition Functions

- `with_min/2` - add minimum bound to constraint
- `with_max/2` - add maximum bound to constraint

Supports Elixir pipe syntax:
```elixir
Constraint.percentage(50)
|> Constraint.with_min(10)
|> Constraint.with_max(100)
```

#### Resolution Function

`resolve/3` converts constraints to concrete sizes:
- Handles all constraint types
- Supports options for ratio/fill calculations (`:remaining`, `:total_ratio`)
- Applies min/max bounds correctly
- Logs warning when length exceeds available space

#### Helper Functions

- `type/1` - returns constraint type as atom
- `fixed?/1` - true for length constraints
- `flexible?/1` - true for ratio/fill constraints
- `get_min/1`, `get_max/1` - extract bound values
- `unwrap/1` - remove bounds to get inner constraint

## Test Coverage

82 unit tests covering:
- All constructor validations
- Edge cases (zero, boundaries)
- Error conditions
- Resolution for all constraint types
- Composition behavior
- Min/max enforcement
- Helper function accuracy

All tests pass.

## Design Decisions

1. **Struct-based types** - enables pattern matching and clear type checking
2. **Bounds as wrappers** - Min/Max wrap inner constraints for composability
3. **Fill with default constraint** - min/max standalone use Fill as default inner
4. **Round to nearest integer** - percentages round for cell-based layouts
5. **Warning on overflow** - length exceeding space logs but doesn't error

## Integration Points

This module will be used by:
- Section 4.2: Constraint Solver
- Section 4.3: Flex Layout
- Section 4.4: Grid Layout

Components will specify constraints, and the solver will resolve them to concrete sizes.

## Usage Examples

```elixir
alias TermUI.Layout.Constraint

# Fixed sidebar + flexible main content
sidebar = Constraint.length(30)
main = Constraint.fill()

# Responsive with bounds
header = Constraint.percentage(10) |> Constraint.with_min(3) |> Constraint.with_max(10)

# 2:1 ratio split
[Constraint.ratio(2), Constraint.ratio(1)]

# Resolution
Constraint.resolve(Constraint.percentage(50), 100)  # => 50
Constraint.resolve(Constraint.fill(), 100, remaining: 30)  # => 30
```

## Files Modified

- `notes/features/4.1-constraint-types.md` - marked all tasks complete

## How to Test

```bash
mix test test/term_ui/layout/constraint_test.exs
```

## Next Steps

- Section 4.2: Constraint Solver - algorithm to allocate space based on constraints
