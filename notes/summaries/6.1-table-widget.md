# Summary: Section 6.1 - Table Widget

## Implementation Overview

Implemented a comprehensive Table widget for displaying tabular data with virtual scrolling, column layout, selection, and sorting capabilities.

## File Structure

```
lib/term_ui/widgets/
├── table.ex              # Main Table widget (StatefulComponent)
└── table/
    └── column.ex         # Column specification struct
```

## Key Components

### Column Specification

```elixir
# Create columns with various configurations
Column.new(:name, "Name")
Column.new(:age, "Age", width: Constraint.length(10), align: :right)
Column.new(:status, "Status", render: &format_status/1)
```

Features:
- Flexible width constraints (length, ratio, percentage, fill)
- Custom render functions for formatting
- Text alignment (left, center, right)
- Sortable flag per column

### Table Widget

```elixir
Table.new(
  columns: [
    Column.new(:name, "Name"),
    Column.new(:age, "Age", width: Constraint.length(10))
  ],
  data: [%{name: "Alice", age: 30}],
  selection_mode: :single,
  on_select: fn selected -> IO.inspect(selected) end
)
```

## Features Implemented

### 6.1.1 Table Structure
- Column spec with header, key, width, render function
- Data binding accepting list of row maps
- Configuration props: selection_mode, sortable
- Style props: header_style, row_style, selected_style, alternating

### 6.1.2 Column Layout
- Width calculation using constraint solver
- Fixed widths: `Constraint.length(20)`
- Proportional widths: `Constraint.ratio(2)`
- Percentage widths: `Constraint.percentage(50)`
- Fill remaining: `Constraint.fill()`

### 6.1.3 Virtual Scrolling
- Scroll state tracking (scroll_offset)
- Visible range calculation from offset and height
- Row recycling - only visible rows rendered
- Smooth scrolling with keyboard and mouse wheel

### 6.1.4 Selection and Navigation
- Single selection with arrow keys
- Multi-selection with space key toggle
- Keyboard navigation: arrows, PageUp/Down, Home/End
- Mouse click selection
- `on_select` callback for selection changes

### 6.1.5 Sorting
- Sort state tracking (column, direction)
- Toggle sort: nil -> asc -> desc -> nil
- Row sorting by column values
- Sort indicators (▲/▼) in header

## API

### Table Functions

```elixir
# Create table props
Table.new(opts)

# Sort operations
Table.sort_by(state, :column, :asc)
Table.toggle_sort(state, :column)

# Selection operations
Table.get_selection(state)
Table.set_selection(state, [0, 2, 4])
Table.clear_selection(state)

# Scrolling
Table.scroll_to(state, index)
Table.visible_count(state)
Table.total_count(state)
```

### Column Functions

```elixir
# Create column
Column.new(key, header, opts)

# Render cell value
Column.render_cell(column, row)

# Align text
Column.align_text(text, width, :left | :center | :right)
```

## Keyboard Shortcuts

| Key | Action |
|-----|--------|
| ↑/↓ | Move cursor up/down |
| Page Up/Down | Scroll by page |
| Home/End | Jump to first/last |
| Enter | Confirm selection |
| Space | Toggle selection (multi mode) |

## Test Coverage

- **Column tests**: 15 tests
- **Table tests**: 43 tests
- **Total**: 58 tests passing

### Test Categories

- Column creation and configuration
- Cell rendering with custom functions
- Text alignment
- Keyboard navigation
- Selection modes (none, single, multi)
- Sorting (ascending, descending, toggle)
- Virtual scrolling
- Column width calculation
- Render output structure

## Performance

Virtual scrolling enables efficient handling of large datasets:
- Only visible rows are rendered
- Tested with 1000+ row datasets
- Scroll offset clamps to valid range
- Cursor movement auto-scrolls view

## Usage Example

```elixir
defmodule MyApp.UserTable do
  use TermUI.StatefulComponent

  alias TermUI.Widgets.Table
  alias TermUI.Widgets.Table.Column
  alias TermUI.Layout.Constraint

  @impl true
  def init(_props) do
    columns = [
      Column.new(:id, "ID", width: Constraint.length(8)),
      Column.new(:name, "Name", width: Constraint.ratio(2)),
      Column.new(:email, "Email", width: Constraint.ratio(3)),
      Column.new(:status, "Status",
        width: Constraint.length(10),
        render: fn status ->
          case status do
            :active -> "● Active"
            :inactive -> "○ Inactive"
          end
        end
      )
    ]

    users = fetch_users()

    table_props = Table.new(
      columns: columns,
      data: users,
      selection_mode: :single,
      sortable: true,
      on_select: fn [user] -> handle_select(user) end
    )

    {:ok, Table.init(table_props) |> elem(1)}
  end

  @impl true
  def handle_event(event, state) do
    Table.handle_event(event, state)
  end

  @impl true
  def render(state, area) do
    Table.render(state, area)
  end
end
```

## Section 6.1 Complete

The Table widget provides all required functionality:
- ✅ Column specification with flexible configuration
- ✅ Constraint-based column width distribution
- ✅ Virtual scrolling for large datasets
- ✅ Single and multi-row selection
- ✅ Click-to-sort with direction indicators
- ✅ Comprehensive test coverage (58 tests)
