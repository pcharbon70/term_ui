# Summary: Section 3.5 - Essential Widgets

## Overview

Implemented six essential widgets that demonstrate component patterns and provide basic UI building blocks for TermUI applications.

## Widgets Implemented

### 1. Label (`lib/term_ui/widget/label.ex`)
Stateless text display using Component behaviour.

**Features:**
- Text alignment (left, center, right)
- Text wrapping
- Truncation with ellipsis
- Style props (fg, bg, bold, etc.)

**Props:** `text`, `align`, `wrap`, `truncate`, `style`

### 2. Progress (`lib/term_ui/widget/progress.ex`)
Progress indicator using StatefulComponent behaviour.

**Features:**
- Bar mode with filled/empty proportions
- Spinner mode with animated frames
- Percentage display
- Customizable characters

**Props:** `value`, `mode`, `show_percentage`, `filled_char`, `empty_char`, `style`

### 3. Button (`lib/term_ui/widget/button.ex`)
Interactive clickable widget using StatefulComponent behaviour.

**Features:**
- Enter/Space key activation
- Mouse click handling
- Visual states (normal, pressed, disabled)
- Callback on activation

**Props:** `label`, `on_click`, `disabled`, `style`, `pressed_style`

### 4. Block (`lib/term_ui/widget/block.ex`)
Container with border using Container behaviour.

**Features:**
- Border styles: none, single, double, rounded, thick
- Title with alignment (left, center, right)
- Padding support
- Inner area calculation

**Props:** `border`, `title`, `title_align`, `padding`, `style`

### 5. List (`lib/term_ui/widget/list.ex`)
Scrollable selectable list using StatefulComponent behaviour.

**Features:**
- Arrow key navigation
- Home/End/Page Up/Page Down
- Automatic scrolling
- Single and multi-select modes
- Selection callback

**Props:** `items`, `on_select`, `multi_select`, `highlight_style`, `style`

### 6. TextInput (`lib/term_ui/widget/text_input.ex`)
Single-line text entry using StatefulComponent behaviour.

**Features:**
- Character input
- Cursor navigation (left, right, home, end)
- Deletion (backspace, delete)
- Scrolling for long text
- Placeholder text
- Max length enforcement

**Props:** `value`, `placeholder`, `on_change`, `on_submit`, `max_length`, `style`, `cursor_style`

## Architecture Decisions

### RenderNode with Cells
Extended RenderNode to support a `:cells` type for widgets that need fine-grained cell positioning. Added `positioned_cell/4` helper function to create cells with position information.

### Props in State
Widgets store props in state during init to access them in render (since StatefulComponent.render/2 only receives state and area).

### Style Handling
Widgets convert style maps to Style structs and use `positioned_cell/4` helper which safely handles nil/default colors.

## Files Created

### Implementation
- `lib/term_ui/widget/label.ex`
- `lib/term_ui/widget/progress.ex`
- `lib/term_ui/widget/button.ex`
- `lib/term_ui/widget/block.ex`
- `lib/term_ui/widget/list.ex`
- `lib/term_ui/widget/text_input.ex`

### Tests
- `test/term_ui/widget/label_test.exs`
- `test/term_ui/widget/progress_test.exs`
- `test/term_ui/widget/button_test.exs`
- `test/term_ui/widget/block_test.exs`
- `test/term_ui/widget/list_test.exs`
- `test/term_ui/widget/text_input_test.exs`

## Modifications to Existing Files

### `lib/term_ui/component/render_node.ex`
- Added `:cells` node type
- Added `cells` field to struct
- Added `positioned_cell` type definition
- Added `cells/2` constructor function

### `lib/term_ui/component/helpers.ex`
- Added `positioned_cell/4` helper function
- Added `cells/2` delegate to RenderNode

## Test Coverage

130 new unit tests covering:
- Widget initialization
- Event handling
- State updates
- Render output
- Style application
- Edge cases (empty lists, zero width, etc.)

All 1306 tests pass (130 new + 1176 existing).

## Usage Examples

### Label
```elixir
Label.render(%{
  text: "Hello, World!",
  align: :center,
  style: %{fg: :blue}
}, area)
```

### Progress
```elixir
{:ok, state} = Progress.init(%{value: 0.5, show_percentage: true})
Progress.render(state, area)
```

### Button
```elixir
{:ok, state} = Button.init(%{
  label: "Submit",
  on_click: fn -> send(self(), :submitted) end
})
Button.render(state, area)
```

### Block
```elixir
{:ok, state} = Block.init(%{
  border: :rounded,
  title: "Panel",
  title_align: :center
})
Block.render(state, area)
```

### List
```elixir
{:ok, state} = List.init(%{
  items: ["Apple", "Banana", "Cherry"],
  on_select: fn item -> IO.puts(item) end
})
List.render(state, area)
```

### TextInput
```elixir
{:ok, state} = TextInput.init(%{
  placeholder: "Enter name...",
  on_submit: fn value -> IO.puts(value) end
})
TextInput.render(state, area)
```

## Future Considerations

1. **Selection in TextInput** - Currently only cursor, no text selection
2. **Multi-line TextInput** - Would need TextArea widget
3. **Widget theming** - Centralized theme system for consistent styling
4. **Focus indicators** - Integration with FocusManager for visual focus
