# Summary: Section 3.1 Component Behaviours

## Overview

Implemented the foundational behaviour system for TermUI components, establishing standardized interfaces for all widgets. This creates the foundation for The Elm Architecture pattern adapted for OTP.

## Files Created

### Core Modules
- `lib/term_ui/component.ex` - Base Component behaviour for stateless display widgets
- `lib/term_ui/stateful_component.ex` - StatefulComponent behaviour for interactive widgets with state
- `lib/term_ui/container.ex` - Container behaviour for widgets managing children
- `lib/term_ui/component/render_node.ex` - RenderNode struct for render tree representation
- `lib/term_ui/component/helpers.ex` - Shared utility functions and macros

### Test Files
- `test/term_ui/component_test.exs` - 21 tests
- `test/term_ui/stateful_component_test.exs` - 29 tests
- `test/term_ui/container_test.exs` - 25 tests
- `test/term_ui/component/render_node_test.exs` - 24 tests
- `test/term_ui/component/helpers_test.exs` - 35 tests

**Total: 134 new tests**

## Architecture

### Behaviour Hierarchy
```
Component
    |
StatefulComponent (uses Component)
    |
Container (uses StatefulComponent)
```

### Component Behaviour
Base behaviour requiring only `render/2` callback:
- `render(props, area) :: render_tree()`
- Optional: `describe/0`, `default_props/0`
- Uses `__using__` macro to inject aliases, imports, and default implementations

### StatefulComponent Behaviour
Extension with state management and event handling:
- `init(props) :: {:ok, state} | {:ok, state, commands} | {:stop, reason}`
- `handle_event(event, state) :: {:ok, state} | {:ok, state, commands} | {:stop, reason, state}`
- `render(state, area) :: render_tree()`
- Optional: `terminate/2`, `handle_info/2`, `handle_call/3`

### Container Behaviour
Extension for widgets managing children:
- `children(state) :: [child_spec()]`
- `layout(children, state, area) :: [child_layout()]`
- Default vertical stacking layout
- Optional: `route_event/2`, `handle_child_message/3`

### RenderNode Struct
Immutable render tree representation:
- Types: `:text`, `:box`, `:stack`, `:empty`
- Builder functions: `text/1,2`, `box/1,2`, `stack/2,3`, `styled/2`
- Fluent API for dimensions: `width/2`, `height/2`

### Helpers Module
Shared utilities imported via `__using__`:
- `props!/2` - Validate and extract props with type checking
- `merge_styles/1` - Combine multiple styles (CSS cascade)
- `compute_size/1` - Calculate text dimensions
- `truncate_text/2` - Fit text to max width
- `fits_in_rect?/2` - Check if dimensions fit area

## Key Design Decisions

1. **Behaviours over Protocols** - Enables `__using__` macro for default implementations and GenServer integration
2. **Render tree immutability** - Data structures (not processes) enable efficient diffing
3. **Command pattern** - Side effects return commands for testing and predictability
4. **Composable behaviours** - Each level builds on the previous
5. **Minimal required surface** - Only essential callbacks required, rich optional hooks

## Type Definitions

```elixir
# Render tree output
@type render_tree :: RenderNode.t() | [render_tree()] | String.t()

# Component props
@type props :: map()

# Available rendering area
@type rect :: %{x: integer(), y: integer(), width: integer(), height: integer()}

# Side effect commands
@type command :: {:send, pid(), term()} | {:timer, integer(), term()} | term()

# Child specification
@type child_spec :: {module(), props :: map()} | {module(), props :: map(), id :: term()}
```

## Test Results

- All 134 new tests pass
- Total project tests: 943
- No regressions in existing functionality

## Integration Points

- Uses `TermUI.Renderer.Style` from Phase 2 for styling
- RenderNodes will be converted to Buffer cells by renderer
- Area/rect type uses simple map (layout system in Phase 4)
- Commands pattern ready for runtime integration in Section 3.3

## Future Considerations

- `should_update?/2` callback for render optimization
- `receive_props/2` for controlled component pattern
- Focus integration in Section 3.4
- Event routing uses these behaviours in Section 3.3

## Usage Examples

### Stateless Component
```elixir
defmodule MyApp.Label do
  use TermUI.Component

  @impl true
  def render(props, _area) do
    text(props[:text] || "")
  end
end
```

### Stateful Component
```elixir
defmodule MyApp.Counter do
  use TermUI.StatefulComponent

  @impl true
  def init(props) do
    {:ok, %{count: props[:initial] || 0}}
  end

  @impl true
  def handle_event(:increment, state) do
    {:ok, %{state | count: state.count + 1}}
  end

  def handle_event(_event, state), do: {:ok, state}

  @impl true
  def render(state, _area) do
    text("Count: #{state.count}")
  end
end
```

### Container
```elixir
defmodule MyApp.Panel do
  use TermUI.Container

  @impl true
  def init(props) do
    {:ok, %{title: props[:title] || "Panel"}}
  end

  @impl true
  def children(_state) do
    [
      {MyApp.Label, %{text: "Header"}, :header},
      {MyApp.Content, %{}, :content}
    ]
  end

  @impl true
  def handle_event(_event, state), do: {:ok, state}

  @impl true
  def render(state, _area) do
    text(state.title)
  end
end
```
